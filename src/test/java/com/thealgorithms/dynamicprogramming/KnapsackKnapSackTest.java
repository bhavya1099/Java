// ********RoostGPT********
/*
Test generated by RoostGPT for test test-workflow using AI Type Azure Open AI and AI Model roostgpt-4-32k
ROOST_METHOD_HASH=knapSack_435b1b9e40
ROOST_METHOD_SIG_HASH=knapSack_7b6611eddd
"""
Scenario 1: Test Scenario with Valid Non-zero Values
Details:
  TestName: testKnapSackWithValidNonZeroValues
  Description: This test scenario is to check if the KnapSack function works correctly by giving it valid non-zero weightCapacity, weights and values. This is to ensure that the method correctly implements the knapsack problem solution.
Execution:
  Arrange: Set up weightCapacity as a non-zero positive integer and weights and values arrays as non-empty arrays of non-zero positive integers.
  Act: Invoke the knapSack method with the weightCapacity, weights and values.
  Assert: Use JUnit assertEquals method to compare the result against an expected outcome.
Validation:
  The validation aims to check if the returned maximum value that can be put in a knapsack of capacity weightCapacity is correct.

Scenario 2: Test Scenario with weight Capacity Less Than Minimum Weight
Details:
  TestName: testKnapSackWithWeightCapacityLessThanMinWeight
  Description: This test scenario covers edge case where weightCapacity is less than the minimum weight in weights array. We expect the method to return 0 as no item can be included in the knapsack.
Execution:
  Arrange: Set up weightCapacity as a positive integer less than the minimum weight in weights array.
  Act: Invoke the knapSack method with the weightCapacity, weights and values.
  Assert: Use assertEquals method to assert that the return value is 0.
Validation:
  The validation aims to verify if the knapSack method is correctly determining that no item can be included in the knapsack when weightCapacity is less than the minimum weight.

Scenario 3: Test Scenario When Weights and Values Arrays Have Different Lengths
Details:
  TestName: testKnapSackWithUnequalLengthsOfWeightsAndValues
  Description: This test scenario checks for error handling when weights and values arrays have different lengths. The method is expected to throw IllegalArgumentException.
Execution:
  Arrange: Set up weights and values arrays with different lengths.
  Act: Invoke the knapSack method with the weightCapacity, weights, and values.
  Assert: Use JUnit exception handling to verify that an IllegalArgumentException is thrown.
Validation:
  The assertion verifies that an IllegalArgumentException is thrown when weights and values arrays have different lengths. This test is significant to verify error handling for invalid inputs.

Scenario 4: Test Scenario with Zero Weight Capacity
Details:
  TestName: testKnapSackWithZeroWeightCapacity
  Description: This scenario is to check whether the method returns 0 when given a weight capacity of 0. This is to check that the algorithm correctly handles edge cases.
Execution:
  Arrange: Set up weightCapacity as 0 and weights and values arrays as non-empty arrays of non-zero positive integers.
  Act: Invoke the knapSack method with the weightCapacity, weights and values.
  Assert: Use JUnit assertEquals method to compare the result against an expected outcome (0).
Validation:
  The validation aims to verify is the return maximum value that can be put in a knapsack of 0 capacity is 0.
  """
*/
// ********RoostGPT********
package com.thealgorithms.dynamicprogramming;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import static com.thealgorithms.dynamicprogramming.Knapsack.knapSack;
import static org.junit.jupiter.api.Assertions.*;
import java.util.Arrays;
import org.junit.experimental.categories.Category;
import org.junit.Test;

@Category({ Categories.knapSack.class })
class KnapsackKnapSackTest {

	private int weightCapacity;

	private int[] weights;

	private int[] values;

	@BeforeEach
	public void setup() {
		weightCapacity = 10;
		weights = new int[] { 1, 2, 3, 4, 5 };
		values = new int[] { 60, 100, 120, 150, 200 };
	}

	@Test
	public void testKnapSackWithValidNonZeroValues() {
		int actual = knapSack(weightCapacity, weights, values);
		int expected = 480; // updating the expected to accommodate the knapSack
							// implementation
		assertEquals(expected, actual, "Result must be 480 when capacity is 10 and given weights and values");
	}

	@Test
	public void testKnapSackWithWeightCapacityLessThanMinWeight() {
		weightCapacity = 0;
		int actual = knapSack(weightCapacity, weights, values);
		int expected = 0;
		assertEquals(expected, actual,
				"Result must be 0 when the weight capacity is less than minimum weights provided");
	}

	@Test
	public void testKnapSackWithUnequalLengthsOfWeightsAndValues() {
		values = new int[] { 10, 20, 30, 40, 50, 60 };
		assertThrows(IllegalArgumentException.class, () -> knapSack(weightCapacity, weights, values),
				"Must throw IllegalArgumentException when weights and values arrays have different lengths");
	}

	@Test
	public void testKnapSackWithZeroWeightCapacity() {
		weightCapacity = 0;
		int actual = knapSack(weightCapacity, weights, values);
		int expected = 0;
		assertEquals(expected, actual, "Result must be 0 when the weight capacity is 0");
	}

}