
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type  and AI Model

ROOST_METHOD_HASH=activitySelection_77631a6e2d
ROOST_METHOD_SIG_HASH=activitySelection_bf79d28a9f

```
Scenario 1: No activities provided
Details:
  TestName: activitySelectionWithNoActivities
  Description: Tests the behavior of the activitySelection method when no activities are provided, i.e., both startTimes and endTimes arrays are empty.
Execution:
  Arrange: Initialize empty startTimes and endTimes arrays.
  Act: Invoke activitySelection with these empty arrays.
  Assert: Check if the returned list is empty.
Validation:
  The assertion verifies that the method correctly handles the case of no input activities by returning an empty list, confirming the method's ability to deal with edge cases gracefully.

Scenario 2: Single activity provided
Details:
  TestName: activitySelectionWithSingleActivity
  Description: Tests the behavior when only a single activity is provided.
Execution:
  Arrange: Create startTimes and endTimes arrays each containing a single value.
  Act: Call activitySelection using the provided arrays.
  Assert: Check if the returned list contains exactly one activity index, and it is correct.
Validation:
  This verifies that the method can handle the simplest non-trivial case of a single activity by returning the single activity itself, which should always be compatible with itself.

Scenario 3: Multiple activities with no conflicts
Details:
  TestName: activitySelectionWithNonConflictingActivities
  Description: Tests the method with multiple activities where all activities can be attended because they do not overlap.
Execution:
  Arrange: Define startTimes and endTimes such that all activities have different times with no overlaps.
  Act: Use activitySelection to determine the list of activities.
  Assert: Ensure that all provided activities are included in the result.
Validation:
  This confirms that the method correctly identifies all compatible activities when none overlap, demonstrating its efficiency in maximizing activity selection.

Scenario 4: Multiple activities with all conflicts
Details:
  TestName: activitySelectionWithConflictingActivities
  Description: Every activity conflicts with each other, allowing for the selection of only one.
Execution:
  Arrange: Setup startTimes and endTimes such that every activity overlaps with every other.
  Act: Run activitySelection on the provided data.
  Assert: Confirm that the result contains only one activity.
Validation:
  This test ensures that the method picks the best single activity when all are in conflict, usually the one that ends the earliest, demonstrating proper handling of completely conflicting schedules.

Scenario 5: Proper activity overlap handling
Details:
  TestName: activitySelectionWithComplexOverlaps
  Description: Input multiple activities with various overlaps to assess if the algorithm selects the maximum number of non-overlapping activities.
Execution:
  Arrange: Start and end times are defined where some activities overlap and others do not.
  Act: Apply activitySelection to these times.
  Assert: Check that the result matches the expected selection of non-overlapping activities.
Validation:
  This scenario checks for the heuristic's correctness under real-world conditions, where selections need to be made amidst a mix of overlapping and non-overlapping schedules.

Scenario 6: Input arrays of unequal length
Details:
  TestName: activitySelectionWithUnequalArrays
  Description: Ensures the method behaves correctly when provided startTimes and endTimes arrays of unequal lengths, which might indicate a mistake in input preparation.
Execution:
  Arrange: Set up startTimes and endTimes arrays of different lengths.
  Act: Attempt to call activitySelection and catch any potential exceptions or errors.
  Assert: An appropriate exception is thrown or a specific error handling behavior occurs.
Validation:
  This tests the method's robustness against input errors, ensuring that it either fails safely or alerts the user to the input mismatch.
```

Each of these scenarios addresses a key aspect of the method's functionality, from basic behavior to handling complex and erroneous inputs, thereby ensuring comprehensive test coverage of the method's operational scope.
*/

// ********RoostGPT********

package com.thealgorithms.greedyalgorithms;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;
import org.junit.jupiter.api.*;

public class ActivitySelectionActivitySelectionTest {

	@Test
	@Tag("boundary")
	public void activitySelectionWithNoActivities() {
		int[] startTimes = {};
		int[] endTimes = {};
		ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
		assertThat(result).isEmpty();
	}

	@Test
	@Tag("valid")
	public void activitySelectionWithSingleActivity() {
		int[] startTimes = { 1 };
		int[] endTimes = { 2 };
		ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
		assertThat(result).containsExactly(0);
	}

	@Test
	@Tag("valid")
	public void activitySelectionWithNonConflictingActivities() {
		int[] startTimes = { 1, 3, 5 };
		int[] endTimes = { 2, 4, 6 };
		ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
		assertThat(result).containsExactly(0, 1, 2);
	}

	@Test
	@Tag("valid")
	public void activitySelectionWithConflictingActivities() {
		int[] startTimes = { 1, 2, 3 };
		int[] endTimes = { 4, 5, 6 };
		ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
		assertThat(result).containsExactly(0);
	}

	@Test
	@Tag("integration")
	public void activitySelectionWithComplexOverlaps() {
		int[] startTimes = { 1, 3, 0, 5, 8, 5 };
		int[] endTimes = { 2, 4, 6, 7, 9, 10 };
		ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
		assertThat(result).containsExactly(2, 3, 4);
	}

	@Test
	@Tag("invalid")
	public void activitySelectionWithUnequalArrays() {
		int[] startTimes = { 1, 2, 3, 4 };
		int[] endTimes = { 2, 3 };
		Exception exception = assertThrows(ArrayIndexOutOfBoundsException.class,
				() -> ActivitySelection.activitySelection(startTimes, endTimes));
		assertThat(exception).isInstanceOf(ArrayIndexOutOfBoundsException.class);
	}

}