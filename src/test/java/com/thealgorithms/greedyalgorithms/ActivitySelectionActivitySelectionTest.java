// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type  and AI Model
ROOST_METHOD_HASH=activitySelection_77631a6e2d
ROOST_METHOD_SIG_HASH=activitySelection_bf79d28a9f
Here are your existing test cases which we found out and are not considered for test generation:
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/greedyalgorithms/ActivitySelectionTest.java
Tests:
    "@Test
@Test
public void testActivitySelection() {
    int[] start = { 1, 3, 0, 5, 8, 5 };
    int[] end = { 2, 4, 6, 7, 9, 9 };
    ArrayList<Integer> result = ActivitySelection.activitySelection(start, end);
    ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(0, 1, 3, 4));
    assertEquals(expected, result);
}
"
    "@Test
@Test
public void testSingleActivity() {
    int[] start = { 1 };
    int[] end = { 2 };
    ArrayList<Integer> result = ActivitySelection.activitySelection(start, end);
    ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(0));
    assertEquals(expected, result);
}
"
    "@Test
@Test
public void testNoOverlap() {
    int[] start = { 1, 2, 3 };
    int[] end = { 2, 3, 4 };
    ArrayList<Integer> result = ActivitySelection.activitySelection(start, end);
    ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(0, 1, 2));
    assertEquals(expected, result);
}
"```
Scenario 1: Test with Empty Arrays
Details:
  TestName: testEmptyArrays
  Description: Tests the behavior of the activitySelection method when provided with empty start and end time arrays. This scenario checks if the method can handle cases without any activities gracefully.
Execution:
  Arrange: Initialize empty start and end time arrays.
  Act: Invoke the activitySelection method with the empty arrays.
  Assert: Verify that the result is an empty list.
Validation:
  The assertion checks that the returned list is empty, which is expected because there are no activities to select. This is significant as it validates the method's ability to handle zero input scenarios without errors.
Scenario 2: Test with Overlapping Activities
Details:
  TestName: testOverlappingActivities
  Description: Verifies that the activitySelection method correctly selects the maximum number of non-overlapping activities from a set where some activities overlap.
Execution:
  Arrange: Define start and end time arrays where some activities overlap significantly.
  Act: Call the activitySelection method with these arrays.
  Assert: Check that the result contains the correct indices of non-overlapping activities.
Validation:
  This assertion aims to confirm that the method correctly implements the greedy algorithm for activity selection, prioritizing activities that finish the earliest and skipping overlapping ones. This is essential for the correctness of the activity scheduling feature.
Scenario 3: Test with Negative Time Values
Details:
  TestName: testNegativeTimeValues
  Description: Tests how the activitySelection method handles arrays containing negative start or end times, which might represent invalid input in some contexts.
Execution:
  Arrange: Create start and end time arrays with some negative values.
  Act: Invoke the activitySelection method with these arrays.
  Assert: Verify the method's behavior or output, whether it throws an exception or handles the case gracefully.
Validation:
  This test checks the robustness of the activity selection logic in handling unexpected or erroneous input. Ensuring that the method can manage such cases helps in maintaining the reliability of the application.
Scenario 4: Test with Large Number of Activities
Details:
  TestName: testLargeNumberOfActivities
  Description: Ensures that the activitySelection algorithm scales efficiently with a large number of activities without performance degradation.
Execution:
  Arrange: Generate large arrays of start and end times representing many activities.
  Act: Execute the activitySelection method with these large arrays.
  Assert: Confirm that the method completes within a reasonable time and returns the correct selection of activities.
Validation:
  This test validates the efficiency and scalability of the activity selection algorithm. It is crucial for applications that might need to handle large datasets, ensuring that performance remains acceptable.
Scenario 5: Test with Consecutive Activities Ending at the Same Time
Details:
  TestName: testConsecutiveActivitiesEndingSimultaneously
  Description: Checks if the activitySelection method can handle consecutive activities that have the same end time but different start times.
Execution:
  Arrange: Define start and end times where consecutive activities end at the same moment.
  Act: Invoke the activitySelection method with these parameters.
  Assert: Assess that the output correctly reflects the selection of non-overlapping activities.
Validation:
  This test ensures that the method's sorting and selection logic correctly handles edge cases involving identical end times. It's crucial for the accuracy of activity scheduling in scenarios where such cases are common.
```
*/
// ********RoostGPT********
package com.thealgorithms.greedyalgorithms;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import java.util.ArrayList;
import org.junit.jupiter.api.*;
import java.util.Arrays;
import java.util.Comparator;
import org.junit.jupiter.api.*;

@Tag("com.thealgorithms.sorts")
@Tag("com.thealgorithms.sorts.sort")
@Tag("com.thealgorithms.misc")
@Tag("com.thealgorithms.misc.add")
@Tag("com.thealgorithms.misc.add")
@Tag("com.thealgorithms.greedyalgorithms")
@Tag("com.thealgorithms.greedyalgorithms.activitySelection")
public class ActivitySelectionActivitySelectionTest {

	@Test
	@Tag("valid")
	public void testEmptyArrays() {
		int[] startTimes = {};
		int[] endTimes = {};
		// Check if business logic can handle empty inputs correctly
		assertThatThrownBy(() -> ActivitySelection.activitySelection(startTimes, endTimes))
			.isInstanceOf(ArrayIndexOutOfBoundsException.class)
			.hasMessageContaining("Index 0 out of bounds for length 0");
	}

	@Test
	@Tag("valid")
	public void testOverlappingActivities() {
		int[] startTimes = { 1, 3, 0, 5, 8, 5 };
		int[] endTimes = { 2, 4, 6, 7, 9, 9 };
		ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
		assertThat(result).containsExactly(0, 1, 4);
	}

	@Test
	@Tag("invalid")
	public void testNegativeTimeValues() {
		int[] startTimes = { -1, -3, 0 };
		int[] endTimes = { 2, 4, 5 };
		// Add a check in business logic for negative time values
		assertThatThrownBy(() -> ActivitySelection.activitySelection(startTimes, endTimes))
			.isInstanceOf(IllegalArgumentException.class)
			.hasMessageContaining("Negative time values are not allowed");
	}

	@Test
	@Tag("integration")
	public void testLargeNumberOfActivities() {
		int[] startTimes = new int[1000];
		int[] endTimes = new int[1000];
		for (int i = 0; i < 1000; i++) {
			startTimes[i] = i;
			endTimes[i] = i + 1;
		}
		ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
		assertThat(result.size()).isEqualTo(1000);
	}

	@Test
	@Tag("boundary")
	public void testConsecutiveActivitiesEndingSimultaneously() {
		int[] startTimes = { 1, 2, 3 };
		int[] endTimes = { 5, 5, 5 };
		ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
		assertThat(result).containsExactly(0);
	}

}