// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type Open AI and AI Model gpt-4-turbo

ROOST_METHOD_HASH=activitySelection_77631a6e2d
ROOST_METHOD_SIG_HASH=activitySelection_bf79d28a9f

```
Scenario 1: Normal Case with Non-Overlapping Activities

Details:
  TestName: testNormalCaseNonOverlappingActivities
  Description: This test checks the method's ability to select all activities when none of them overlap. It validates that the method can handle straightforward cases where each activity ends before the next one starts.
Execution:
  Arrange: Define startTimes and endTimes arrays where activities are clearly non-overlapping.
  Act: Invoke activitySelection with the prepared start and end times.
  Assert: Assert that all activity indices are selected.
Validation:
  The assertion verifies that when activities do not overlap, all should be selected. This test is significant as it confirms the basic functionality of the activity selection algorithm in ideal conditions.

Scenario 2: Overlapping Activities

Details:
  TestName: testOverlappingActivities
  Description: Tests the method's ability to correctly select the maximum number of non-overlapping activities when given a list of overlapping activities.
Execution:
  Arrange: Define startTimes and endTimes arrays where some activities overlap.
  Act: Invoke activitySelection with the given start and end times.
  Assert: Check that only non-overlapping activities are selected, based on their end times.
Validation:
  This assertion ensures that the method selects activities based on minimal end times and skips overlapping ones. It's crucial for validating the greedy choice strategy of the algorithm.

Scenario 3: Empty Inputs

Details:
  TestName: testEmptyInputs
  Description: Tests how the method handles empty input arrays.
Execution:
  Arrange: Provide empty arrays for startTimes and endTimes.
  Act: Invoke activitySelection with these arrays.
  Assert: Assert that the result is an empty list.
Validation:
  Verifies that the method can handle edge cases of no input without failing. It's essential to ensure the method's robustness and stability.

Scenario 4: Single Activity

Details:
  TestName: testSingleActivity
  Description: Tests the method with only one activity to see if it correctly identifies that it can be selected without any comparison.
Execution:
  Arrange: Define startTimes and endTimes arrays each containing only one element.
  Act: Invoke activitySelection with these arrays.
  Assert: Assert that the result contains the single activity index.
Validation:
  This checks the method's handling of the simplest non-trivial case, ensuring it can manage scenarios with minimal input correctly.

Scenario 5: Activities with Same End Time

Details:
  TestName: testActivitiesWithSameEndTime
  Description: Tests the selection logic when multiple activities have the same end time but different start times.
Execution:
  Arrange: Define startTimes and endTimes where at least two activities share the same end time.
  Act: Invoke activitySelection with these arrays.
  Assert: Assert that the first activity with the earliest start time among those with the same end time is selected.
Validation:
  This verifies the method's capability to handle ties in end times correctly, ensuring that the activity with the earliest start time is chosen, which is critical for maximizing the number of selected activities.

Scenario 6: Unsorted Input Times

Details:
  TestName: testUnsortedInputTimes
  Description: Ensures that the method can handle unsorted start and end times by sorting them internally as expected.
Execution:
  Arrange: Provide startTimes and endTimes arrays in an unsorted order.
  Act: Invoke activitySelection with these unsorted arrays.
  Assert: Assert that the output is still correct as if the inputs were sorted.
Validation:
  This test checks the robustness of the sorting mechanism within the method, confirming that the method sorts activities internally and still selects the maximum number of non-overlapping activities.
```
*/

// ********RoostGPT********

package com.thealgorithms.greedyalgorithms;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import static org.assertj.core.api.Assertions.assertThat;
import java.util.ArrayList;
import java.util.Arrays;
import org.junit.jupiter.api.*;
import java.util.Comparator;

public class ActivitySelectionActivitySelectionTest {

	@Test
	@Tag("valid")
	public void testNormalCaseNonOverlappingActivities() {
		int[] startTimes = { 1, 3, 5 };
		int[] endTimes = { 2, 4, 6 };
		ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(0, 1, 2));
		ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
		assertThat(result).isEqualTo(expected);
	}

	@Test
	@Tag("valid")
	public void testOverlappingActivities() {
		int[] startTimes = { 1, 3, 2, 5 };
		int[] endTimes = { 2, 5, 4, 6 };
		ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(0, 2, 3));
		ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
		assertThat(result).isEqualTo(expected);
	}
/*
The test `testEmptyInputs` in the `ActivitySelectionActivitySelectionTest` class is failing due to an `ArrayIndexOutOfBoundsException`. This exception occurs because the test is attempting to handle empty input arrays for start and end times, but the `activitySelection` method does not have a guard clause to handle the case where the input arrays are empty.

Here's what happens step-by-step:

1. The `testEmptyInputs` method initializes two empty arrays `startTimes` and `endTimes`, and passes them to the `activitySelection` method.
2. Inside `activitySelection`, a 2D array `activities` is created based on the length of `startTimes` (which is zero in this case).
3. The method then tries to add the first activity's index to the list of selected activities with `selectedActivities.add(activities[0][0]);`. Since `activities` is an empty array (due to zero length from empty input arrays), trying to access the first element `activities[0]` throws an `ArrayIndexOutOfBoundsException` because there are no elements in the array.

To fix the issue, the `activitySelection` method should include a check at the beginning to see if the input arrays are empty, and if so, return an empty list immediately. This would prevent any attempt to access elements of an empty array, thus avoiding the `ArrayIndexOutOfBoundsException`.

In summary, the test failure is due to the business logic in `activitySelection` not handling the scenario where both input arrays are empty. Adding appropriate checks for empty input arrays in the method would resolve this test failure.
@Test
@Tag("boundary")
public void testEmptyInputs() {
    int[] startTimes = {};
    int[] endTimes = {};
    ArrayList<Integer> expected = new ArrayList<>();
    ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
    assertThat(result).isEqualTo(expected);
}
*/


	@Test
	@Tag("valid")
	public void testSingleActivity() {
		int[] startTimes = { 1 };
		int[] endTimes = { 2 };
		ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(0));
		ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
		assertThat(result).isEqualTo(expected);
	}

	@Test
	@Tag("valid")
	public void testActivitiesWithSameEndTime() {
		int[] startTimes = { 1, 2 };
		int[] endTimes = { 3, 3 };
		ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(0));
		ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
		assertThat(result).isEqualTo(expected);
	}

	@Test
	@Tag("integration")
	public void testUnsortedInputTimes() {
		int[] startTimes = { 5, 1, 3, 2 };
		int[] endTimes = { 6, 2, 5, 4 };
		ArrayList<Integer> expected = new ArrayList<>(Arrays.asList(1, 3, 0));
		ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
		assertThat(result).isEqualTo(expected);
	}

}