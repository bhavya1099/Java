// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type Azure Open AI and AI Model roostgpt-4-32k
ROOST_METHOD_HASH=activitySelection_77631a6e2d
ROOST_METHOD_SIG_HASH=activitySelection_bf79d28a9f
Scenario 1: Test method with an empty arrays
Details:  
  TestName: activitySelectionWithEmptyArray
  Description: This test case aims to check the behaviour of the method when provided with empty arrays. 
Execution:
  Arrange: Initialize startTimes and endTimes arrays as empty arrays.
  Act: Invoke activitySelection method of ActivitySelection entity with the empty arrays.
  Assert: Assert that the resulting ArrayList is also empty.
Validation: 
  The assertion verifies that the method is handling empty input arrays correctly by returning an empty result in such cases. This test is crucial in making sure that the software can gracefully handle edge cases.
Scenario 2: Validate selection algorithm with overlapping activities
Details:
  TestName: validateActivitySelectionWithOverlaps
  Description: This test targets the algorithm that selects non-overlapping activities based on their start and end times.
Execution:
  Arrange: Initialize startTimes and endTimes arrays with overlapping activities.
  Act: Invoke activitySelection method of ActivitySelection entity with these arrays.
  Assert: Check that the resulting selected activities do not overlap.
Validation:
  The test verifies that the algorithm accurately selects the maximum number of non-overlapping activities, which is the expected functionality of the selection process implemented in the method.
Scenario 3: Verify selection with single valid activity
Details:
  TestName: activitySelectionWithSingleActivity
  Description: This test case tests the method with a single valid activity. The start and end time arrays each have one element.
Execution:
  Arrange: Initialize startTimes and endTimes arrays with one element each.
  Act: Invoke activitySelection method of ActivitySelection entity with these arrays.
  Assert: Check that the resulting selection array has only one activity.
Validation:
  The assertion verifies that the algorithm handles correctly the case with single activity and returns the correct selection of activities.
Scenario 4: Validate selection with activities having same end times
Details:
  TestName: activitySelectionWithSameEndTimes
  Description: This test checks how the function handles activities that end at the same time.
Execution:
  Arrange: Initialize startTimes and endTimes arrays with activities having same end times.
  Act: Invoke activitySelection method of ActivitySelection entity with these arrays.
  Assert: Assert that the resulting selected activities don't overlap and are sorted by end times. 
Validation:
  The test checks if the function correctly prioritizes selecting the activity that ends first in case multiple activities finish at the same time.
Scenario 5: Test method with null input
Details: 
  TestName: activitySelectionWithNullInput
  Description: This test aims to confirm that the method handles null input gracefully.
Execution: 
  Arrange: Set the input startTimes and endTimes as null.
  Act: Invoke activitySelection method of ActivitySelection entity with null input.
  Assert: Expect an appropriate exception (like NullPointerException) to be thrown.
Validation: 
  This assertion would verify if the method can deal with null inputs, either by throwing an appropriate error or by handling it in some other suitable manner. 
Scenario 6: Testing method with negative time inputs
Details:  
  TestName: activitySelectionWithNegativeTimes
  Description: This test scenario aims to check the method's handling of negative activity start or end times.
Execution: 
  Arrange: Initialize the startTimes and endTimes arrays with some activities having negative start or end times.
  Act: Call the activitySelection method with these time arrays.
  Assert: Assert that the method handles these inputs without any error or exception and returns expected output.
Validation: 
  The test validates that the method can handle unusual inputs like negative time values correctly and still return the correct behaviour.
*/
// ********RoostGPT********
package com.thealgorithms.greedyalgorithms;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import org.junit.jupiter.api.*;

@Tag("com.thealgorithms.sorts")
@Tag("com.thealgorithms.sorts.sort")
@Tag("com.thealgorithms.misc")
@Tag("com.thealgorithms.misc.add")
@Tag("com.thealgorithms.misc.add")
@Tag("com.thealgorithms.greedyalgorithms")
@Tag("com.thealgorithms.greedyalgorithms.activitySelection")
public class ActivitySelectionActivitySelectionTest {
  
  @Test
  @Tag("valid")
  public void activitySelectionWithEmptyArray(){
    int[] startTimes = {};
    int[] endTimes = {};
    ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
    assertTrue(result.isEmpty());
  }
  
  @Test
  @Tag("valid")
  public void validateActivitySelectionWithOverlaps(){
    int[] startTimes = {1, 3, 5, 7};
    int[] endTimes = {2, 4, 6, 8};
    ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
    assertTrue(result.size() == 4 && result.get(0) == 0 && 
               result.get(1) == 1 && result.get(2) == 2 && result.get(3) == 3);
  }
  
  @Test
  @Tag("valid")
  public void activitySelectionWithSingleActivity(){
    int[] startTimes = {1};
    int[] endTimes = {2};
    ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
    assertTrue(result.size() == 1 && result.get(0) == 0);
  }
  
  @Test
  @Tag("valid")
  public void activitySelectionWithSameEndTimes(){
    int[] startTimes = {1, 2, 3};
    int[] endTimes = {3, 3, 3};
    ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
    assertTrue(result.size() == 1 && result.get(0) == 0);
  }
  
  @Test
  @Tag("invalid")
  public void activitySelectionWithNullInput(){
    int[] startTimes = null;
    int[] endTimes = null;
    assertThrows(NullPointerException.class, () -> {
      ActivitySelection.activitySelection(startTimes, endTimes);
    });
  }
  
  @Test
  @Tag("boundary")
  public void activitySelectionWithNegativeTimes(){
    int[] startTimes = {1, -2, 3};
    int[] endTimes = {2, 4, -5};
    ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
    assertTrue(result.size() == 2 && result.get(0) == 0 && result.get(1) == 1);
  }
}