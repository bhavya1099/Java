
// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type  and AI Model

ROOST_METHOD_HASH=activitySelection_77631a6e2d
ROOST_METHOD_SIG_HASH=activitySelection_bf79d28a9f

"""
Scenario 1: No activities given

Details:
  TestName: testEmptyActivityLists
  Description: This test checks the method's behavior with empty start and end times arrays.
Execution:
  Arrange: Prepare empty startTimes and endTimes int arrays.
  Act: Invoke activitySelection method with the empty arrays.
  Assert: Assert that the resulting ArrayList is empty.
Validation:
  This test verifies that when there are no activities to select from, the method correctly returns an empty list of selected activities. This scenario ensures the method gracefully handles the lack of input data.

"""

"""
Scenario 2: Single activity available

Details:
  TestName: testSingleActivity
  Description: This test checks if the method correctly handles the case where there is only one activity.
Execution:
  Arrange: Define startTimes and endTimes arrays each with a single identical element indicating one activity.
  Act: Call activitySelection using the defined start and end times.
  Assert: Assert that the result includes the single available activity.
Validation:
  The assertion checks that the method selects the only activity available when it does not overlap with any other. This confirms the method's functionality in minimal input scenarios.

"""

"""
Scenario 3: Multiple activities, none overlapping

Details:
  TestName: testMultipleNonOverlappingActivities
  Description: Verifies that the method selects all activities when none overlap in time.
Execution:
  Arrange: Provide startTimes and endTimes arrays representing multiple activities with no time overlap.
  Act: Invoke activitySelection with these arrays.
  Assert: Ensure that all activities are selected.
Validation:
  This test will ensure that when given multiple independent activities, the method recognizes and selects each one. This confirms correct handling of multiple input activities and correct application of the activity selection algorithm.

"""

"""
Scenario 4: Multiple activities with complete overlap

Details:
  TestName: testActivitiesWithCompleteOverlap
  Description: Checks the scenario where all activities have overlapping times.
Execution:
  Arrange: Set up startTimes and endTimes where each activity overlaps fully with others.
  Act: Use these arrays in the activitySelection call.
  Assert: Assert that the result only contains the first activity (sorted by end time).
Validation:
  The purpose here is to ascertain that the method picks the activity that finishes first when everything else overlaps, maintaining the most efficient use of available time slots.

"""

"""
Scenario 5: Activities with some overlapping and some non-overlapping

Details:
  TestName: testMixedOverlapActivities
  Description: Assesses the method's performance when given a mix of overlapping and non-overlapping activities.
Execution:
  Arrange: Define startTimes and endTimes arrays where some activities overlap and others donâ€™t.
  Act: Invoke the activitySelection with these parameters.
  Assert: Verify that the result contains only non-overlapping activities, correctly selected based on their ending times.
Validation:
  This scenario tests the complexity where activities are partially independent and partially conflicting. The result verifies effective application logic by choosing the maximum number of non-overlapping activities.

"""

"""
Scenario 6: Negative time values

Details:
  TestName: testNegativeTimeValues
  Description: Ensures that the method can handle negative values in startTimes and endTimes.
Execution:
  Arrange: Create startTimes and endTimes arrays containing negative values.
  Act: Run activitySelection with these arrays.
  Assert: Check that the method handles these inputs without errors and behaves as expected.
Validation:
  It will affirm the robustness of the sorting and selecting algorithm dealing with unconventional but technically permissible input values, such as schedules that might represent relative time rather than absolute.

"""
*/

// ********RoostGPT********

package com.thealgorithms.greedyalgorithms;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import java.util.ArrayList;
import static org.assertj.core.api.Assertions.assertThat;
import org.junit.jupiter.api.*;
import java.util.Arrays;
import java.util.Comparator;

public class ActivitySelectionActivitySelectionTest {

	@Test
	@Tag("valid")
	public void testEmptyActivityLists() {
		int[] startTimes = {};
		int[] endTimes = {};
		ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
		assertThat(result).isEmpty();
	}

	@Test
	@Tag("valid")
	public void testSingleActivity() {
		int[] startTimes = { 1 };
		int[] endTimes = { 2 };
		ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
		assertThat(result).containsExactly(0);
	}

	@Test
	@Tag("valid")
	public void testMultipleNonOverlappingActivities() {
		int[] startTimes = { 1, 3, 5 };
		int[] endTimes = { 2, 4, 6 };
		ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
		assertThat(result).containsExactly(0, 1, 2);
	}

	@Test
	@Tag("valid")
	public void testActivitiesWithCompleteOverlap() {
		int[] startTimes = { 1, 1, 1 };
		int[] endTimes = { 2, 2, 2 };
		ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
		assertThat(result).containsExactly(0);
	}

	@Test
	@Tag("valid")
	public void testMixedOverlapActivities() {
		int[] startTimes = { 1, 3, 0, 5, 4 };
		int[] endTimes = { 4, 5, 2, 7, 6 };
		ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
		assertThat(result).containsExactly(2, 1, 4);
	}

	@Test
	@Tag("boundary")
	public void testNegativeTimeValues() {
		int[] startTimes = { -3, -1, -5 };
		int[] endTimes = { -1, 0, -2 };
		ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
		assertThat(result).containsExactly(2, 0);
	}

}