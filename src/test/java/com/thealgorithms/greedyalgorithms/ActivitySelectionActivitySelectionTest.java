// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type Open AI and AI Model gpt-4
ROOST_METHOD_HASH=activitySelection_cce0da1981
ROOST_METHOD_SIG_HASH=activitySelection_79d2670611
"""
Scenario 1: Test with valid start and end times
Details:
  TestName: testActivitySelectionWithValidTimes
  Description: This test is meant to check the functionality of the activitySelection method when provided with valid start and end times. The target scenario is when all activities have non-overlapping times.
Execution:
  Arrange: Create two arrays for startTimes and endTimes with non-overlapping times.
  Act: Invoke the activitySelection method with these arrays.
  Assert: Use JUnit assertions to check if the returned ArrayList contains all the activities.
Validation:
  The assertion verifies that the activitySelection method correctly identifies all the activities when their times do not overlap. This is important for the core functionality of the method.
Scenario 2: Test with overlapping times
Details:
  TestName: testActivitySelectionWithOverlappingTimes
  Description: This test checks the method's ability to select the maximum number of activities that can be performed by a single person, assuming that a person can only work on a single activity at a time.
Execution:
  Arrange: Create two arrays for startTimes and endTimes with overlapping times.
  Act: Invoke the activitySelection method with these arrays.
  Assert: Use JUnit assertions to check if the returned ArrayList contains the maximum number of non-overlapping activities.
Validation:
  The assertion verifies that the method accurately selects the maximum number of non-overlapping activities. This is critical for the functionality of the method as it is designed to maximize the number of activities.
Scenario 3: Test with empty arrays
Details:
  TestName: testActivitySelectionWithEmptyArrays
  Description: This test checks the method's ability to handle empty input arrays.
Execution:
  Arrange: Create two empty arrays for startTimes and endTimes.
  Act: Invoke the activitySelection method with these arrays.
  Assert: Use JUnit assertions to check if the returned ArrayList is empty.
Validation:
  The assertion verifies that the method can handle empty input arrays and correctly returns an empty ArrayList.
Scenario 4: Test with null arrays
Details:
  TestName: testActivitySelectionWithNullArrays
  Description: This test checks the method's ability to handle null input arrays.
Execution:
  Arrange: Provide null for startTimes and endTimes arrays.
  Act: Invoke the activitySelection method with these arrays.
  Assert: Use JUnit assertions to expect a NullPointerException.
Validation:
  The assertion verifies that the method throws a NullPointerException when provided with null input arrays, as it should. This checks the method's error handling capabilities.
Scenario 5: Test with unequal size arrays
Details:
  TestName: testActivitySelectionWithUnequalSizeArrays
  Description: This test checks the method's behavior when the startTimes and endTimes arrays are of unequal sizes.
Execution:
  Arrange: Create two arrays for startTimes and endTimes of unequal sizes.
  Act: Invoke the activitySelection method with these arrays.
  Assert: Use JUnit assertions to expect an ArrayIndexOutOfBoundsException.
Validation:
  The assertion verifies that the method throws an ArrayIndexOutOfBoundsException when provided with startTimes and endTimes arrays of unequal sizes. This checks the method's error handling capabilities.
"""
*/
// ********RoostGPT********
package com.thealgorithms.greedyalgorithms;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import org.junit.jupiter.api.*;

@Tag("com.thealgorithms.greedyalgorithms")
@Tag("com.thealgorithms.greedyalgorithms.activitySelection")
@Tag("roostTestTag1")
@Tag("roostTestTag2")
public class ActivitySelectionActivitySelectionTest {

	@Test
	public void testActivitySelectionWithValidTimes() {
		// Arrange
		int[] startTimes = { 1, 3, 0, 5, 8, 5 };
		int[] endTimes = { 2, 4, 6, 7, 9, 9 };
		// Act
		ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
		// Assert
		assertEquals(Arrays.asList(0, 1, 3, 4), result);
	}

	@Test
	public void testActivitySelectionWithOverlappingTimes() {
		// Arrange
		int[] startTimes = { 1, 3, 0, 5, 8, 5 };
		int[] endTimes = { 2, 4, 7, 7, 9, 9 };
		// Act
		ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
		// Assert
		assertEquals(Arrays.asList(0, 1, 4), result);
	}

	@Test
	public void testActivitySelectionWithEmptyArrays() {
		// Arrange
		int[] startTimes = {};
		int[] endTimes = {};
		// Act
		ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
		// Assert
		assertTrue(result.isEmpty());
	}

	@Test
	public void testActivitySelectionWithNullArrays() {
		// Arrange
		int[] startTimes = null;
		int[] endTimes = null;
		// Act & Assert
		assertThrows(NullPointerException.class, () -> ActivitySelection.activitySelection(startTimes, endTimes));
	}

	@Test
	public void testActivitySelectionWithUnequalSizeArrays() {
		// Arrange
		int[] startTimes = { 1, 3, 0, 5, 8 };
		int[] endTimes = { 2, 4, 6, 7, 9, 9 };
		// Act & Assert
		assertThrows(ArrayIndexOutOfBoundsException.class,
				() -> ActivitySelection.activitySelection(startTimes, endTimes));
	}

}