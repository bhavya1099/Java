// ********RoostGPT********
/*
Test generated by RoostGPT for test test-workflow using AI Type Azure Open AI and AI Model roostgpt-4-32k
ROOST_METHOD_HASH=activitySelection_77631a6e2d
ROOST_METHOD_SIG_HASH=activitySelection_bf79d28a9f
"""
Scenario 1: Validate the selection of activities with non-overlapping timings
Details:
  TestName: testActivitySelectionForNonOverlappingActivities
  Description: This test validates the activitySelection function for a set of activities whose start time is after the end time of previous activity.
Execution:
  Arrange: Provide start and end times for the activities, such that no activity overlaps with another.
  Act: Invoke the activitySelection function with the prepared start and end times.
  Assert: The function should return all activities in order, as all activities can be attended without overlap.
Validation:
  The test checks if the function is able to select all activities in scenarios where they do not overlap time-wise.
Scenario 2: Validate selection of activities with overlapping timings
Details:
  TestName: testActivitySelectionForOverlappingActivities
  Description: This test verifies the activitySelection function for a set of activities with overlapping start and end times.
Execution:
  Arrange: Provide start and end times which overlaps with one or more other activities.
  Act: Invoke the activitySelection function with the prepared start/end times.
  Assert: The function should return a subset of activities that can be attended sans overlap.
Validation:
  The test checks if the function correctly selects a subset of activities in a way that none of them overlap with each other.
Scenario 3: Validate selection of activities with identical timings
Details:
  TestName: testActivitySelectionForIdenticalTimingActivities
  Description: This test verifies the activitySelection function for a set of activities with identical start and end times.
Execution:
  Arrange: Provide identical start/end times for all activities.
  Act: Invoke the activitySelection function with the prepared start/end times.
  Assert: The function should return the first activity only, as it would not be feasible to participate in other activities due to the identical timing.
Validation:
  The test checks if the function selects only 1 activity from a set of activities having identical timings.
Scenario 4: Validate handling of negative timings
Details:
  TestName: testActivitySelectionForNegativeTimingsActivities
  Description: This test is meant to ensure the function's error handling for activities with negative start/end times.
Execution:
  Arrange: Provide negative start/end times for some or all activities.
  Act: Invoke the activitySelection function with the prepared start/end times.
  Assert: The function should throw an exception or handle the error appropriately, based on program requirements.
Validation:
  This test verifies the function's ability to handle invalid input (negative times) effectively.
Scenario 5: Validate sorting of activities based on end times
Details:
  TestName: testActivitySortingByEndTimeInActivitySelection
  Description: This test checks whether or not the function sorts the activities by their end times, which is crucial for optimal selection.
Execution:
  Arrange: Define start/end times for activities with various end times as not in ordered sequence.
  Act: Invoke the activitySelection function with the defined start/end times.
  Assert: The function should return the activities in the order that they end, irrespective of the order they were input in.
Validation:
  The test verifies that the function is properly sorting activities by end time before applying the selection algorithm.
"""
*/
// ********RoostGPT********
package com.thealgorithms.greedyalgorithms;

import org.junit.jupiter.api.Test;
import java.util.ArrayList;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import java.util.Arrays;
import java.util.Comparator;
import org.junit.jupiter.api.*;

@Tag("com.thealgorithms.sorts")
@Tag("com.thealgorithms.sorts.sort")
@Tag("com.thealgorithms.misc")
@Tag("com.thealgorithms.misc.add")
@Tag("com.thealgorithms.misc.add")
@Tag("com.thealgorithms.greedyalgorithms")
@Tag("com.thealgorithms.greedyalgorithms.activitySelection")
@Tag("roostTest1")
@Tag("roostTest2")
public class ActivitySelectionActivitySelectionTest {

	@Test
	public void testActivitySelectionForNonOverlappingActivities() {
		int[] startTimes = new int[] { 1, 3, 2, 5 };
		int[] endTimes = new int[] { 2, 4, 3, 6 };
		ArrayList<Integer> expectedActivities = new ArrayList<>();
		expectedActivities.add(0);
		expectedActivities.add(1);
		expectedActivities.add(3);
		assertEquals(expectedActivities, ActivitySelection.activitySelection(startTimes, endTimes));
	}

	@Test
	public void testActivitySelectionForOverlappingActivities() {
		int[] startTimes = new int[] { 1, 3, 0, 5, 8, 5 };
		int[] endTimes = new int[] { 2, 4, 6, 7, 9, 10 };
		ArrayList<Integer> expectedActivities = new ArrayList<>();
		expectedActivities.add(0);
		expectedActivities.add(1);
		expectedActivities.add(4);
		assertEquals(expectedActivities, ActivitySelection.activitySelection(startTimes, endTimes));
	}

	@Test
	public void testActivitySelectionForIdenticalTimingActivities() {
		int[] startTimes = new int[] { 1, 1, 1, 1 };
		int[] endTimes = new int[] { 2, 2, 2, 2 };
		ArrayList<Integer> expectedActivities = new ArrayList<>();
		expectedActivities.add(0);
		assertEquals(expectedActivities, ActivitySelection.activitySelection(startTimes, endTimes));
	}

	@Test
	public void testActivitySelectionForNegativeTimingsActivities() {
		int[] startTimes = new int[] { -1, -3, -2, -5 };
		int[] endTimes = new int[] { -2, -4, -3, -6 };
		assertThrows(IllegalArgumentException.class, () -> ActivitySelection.activitySelection(startTimes, endTimes));
	}

	@Test
	public void testActivitySortingByEndTimeInActivitySelection() {
		int[] startTimes = new int[] { 8, 5, 0, 3, 5, 1 };
		int[] endTimes = new int[] { 9, 7, 6, 4, 10, 2 };
		ArrayList<Integer> result = ActivitySelection.activitySelection(startTimes, endTimes);
		assertTrue(isSorted(result, endTimes));
	}

	private boolean isSorted(ArrayList<Integer> result, int[] endTimes) {
		for (int i = 1; i < result.size(); i++) {
			if (endTimes[result.get(i - 1)] > endTimes[result.get(i)]) {
				return false;
			}
		}
		return true;
	}

}