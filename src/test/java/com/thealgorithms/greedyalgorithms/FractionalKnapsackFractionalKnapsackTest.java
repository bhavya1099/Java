// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type Open AI and AI Model gpt-4-turbo

ROOST_METHOD_HASH=fractionalKnapsack_b327dd7d5e
ROOST_METHOD_SIG_HASH=fractionalKnapsack_1caf503527

```
Scenario 1: Valid Input With Full Capacity Utilization

Details:
  TestName: testValidInputFullCapacity
  Description: This test checks whether the method correctly calculates the maximum value possible when all items can fit within the given capacity without needing to take a fraction of any item.
Execution:
  Arrange: Define arrays for weights and values, and set a capacity that can accommodate all items.
  Act: Call the fractionalKnapsack method with the defined weights, values, and capacity.
  Assert: Compare the returned value with the expected maximum value.
Validation:
  This assertion verifies that the method can optimally select items when they all can fit within the knapsack, ensuring that the algorithm correctly handles simple cases of capacity management.
  The significance of this test is to confirm basic functionality and correct computation of total values without fractions.

Scenario 2: Valid Input With Partial Capacity Utilization

Details:
  TestName: testValidInputPartialCapacity
  Description: This test evaluates how the method handles scenarios where only a fraction of some items can be added to achieve maximum value due to capacity constraints.
Execution:
  Arrange: Define arrays for weights and values, and set a capacity that requires fractional selection of at least one item.
  Act: Call the fractionalKnapsack method with the defined weights, values, and capacity.
  Assert: Check if the returned value matches the expected value calculated considering the fractions.
Validation:
  The assertion confirms that the method can handle fractional weights properly and compute the maximum possible value accurately.
  This test is crucial for validating that the algorithm can deal with complex scenarios involving partial item inclusion based on value-to-weight ratios.

Scenario 3: Edge Case With Zero Capacity

Details:
  TestName: testZeroCapacity
  Description: This test verifies the method's response when the capacity of the knapsack is zero, expecting a return value of zero since no items can be added.
Execution:
  Arrange: Define any arrays for weights and values, and set capacity to zero.
  Act: Call the fractionalKnapsack method.
  Assert: Ensure the result is zero.
Validation:
  The assertion checks that the method returns zero when no items can be accommodated, which is expected behavior in this edge case.
  Testing zero capacity is essential to ensure that the method handles edge constraints gracefully.

Scenario 4: Input With All Zero Values

Details:
  TestName: testAllZeroValues
  Description: Tests the function's output when all item values are zero, which should result in a knapsack value of zero regardless of the capacity or weights.
Execution:
  Arrange: Define arrays for weights with any positive numbers and values all set to zero, and set any positive capacity.
  Act: Call the fractionalKnapsack method.
  Assert: Validate that the output is zero.
Validation:
  This test is important to confirm that the method correctly calculates the total value as zero when items have no value, which aligns with practical expectations.
  It ensures the method's robustness in handling cases where item values might not contribute to the knapsack's worth.

Scenario 5: Unequal Arrays Length

Details:
  TestName: testUnequalArraysLength
  Description: This scenario checks the method's behavior when the weight and value arrays are of unequal lengths, which should ideally throw an exception or handle the error gracefully.
Execution:
  Arrange: Define weight array longer than the value array and set any positive capacity.
  Act: Call the fractionalKnapsack method and handle any potential exceptions or errors.
  Assert: Expect an exception or a specific error handling output.
Validation:
  Ensuring that the method can handle or report discrepancies in input array lengths is crucial for avoiding runtime errors in real applications.
  This test checks the robustness and error handling capability of the method under faulty input conditions.
```
*/

// ********RoostGPT********

package com.thealgorithms.greedyalgorithms;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import org.junit.jupiter.api.*;
import java.util.Arrays;
import java.util.Comparator;

public class FractionalKnapsackFractionalKnapsackTest {

	@Test
	@Tag("valid")
	public void testValidInputFullCapacity() {
		int[] weights = { 10, 20, 30 };
		int[] values = { 60, 100, 120 };
		int capacity = 60;
		int expectedValue = 280;
		int actualValue = FractionalKnapsack.fractionalKnapsack(weights, values, capacity);
		assertEquals(expectedValue, actualValue);
	}

	@Test
	@Tag("valid")
	public void testValidInputPartialCapacity() {
		int[] weights = { 10, 20, 30 };
		int[] values = { 60, 100, 120 };
		int capacity = 50;
		int expectedValue = 240;
		int actualValue = FractionalKnapsack.fractionalKnapsack(weights, values, capacity);
		assertEquals(expectedValue, actualValue);
	}

	@Test
	@Tag("boundary")
	public void testZeroCapacity() {
		int[] weights = { 10, 20, 30 };
		int[] values = { 60, 100, 120 };
		int capacity = 0;
		int expectedValue = 0;
		int actualValue = FractionalKnapsack.fractionalKnapsack(weights, values, capacity);
		assertEquals(expectedValue, actualValue);
	}

	@Test
	@Tag("valid")
	public void testAllZeroValues() {
		int[] weights = { 10, 20, 30 };
		int[] values = { 0, 0, 0 };
		int capacity = 50;
		int expectedValue = 0;
		int actualValue = FractionalKnapsack.fractionalKnapsack(weights, values, capacity);
		assertEquals(expectedValue, actualValue);
	}

	@Test
	@Tag("invalid")
	public void testUnequalArraysLength() {
		int[] weights = { 10, 20, 30, 40 };
		int[] values = { 60, 100, 120 };
		int capacity = 50;
		assertThrows(ArrayIndexOutOfBoundsException.class,
				() -> FractionalKnapsack.fractionalKnapsack(weights, values, capacity));
	}

}