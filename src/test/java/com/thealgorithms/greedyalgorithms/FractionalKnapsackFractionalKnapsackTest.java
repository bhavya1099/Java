// ********RoostGPT********
/*
Test generated by RoostGPT for test test-workflow using AI Type Azure Open AI and AI Model roostgpt-4-32k
ROOST_METHOD_HASH=fractionalKnapsack_b327dd7d5e
ROOST_METHOD_SIG_HASH=fractionalKnapsack_1caf503527
"""
Scenario 1: Test Successful with Valid Data
Details:
    TestName: testFractionalKnapsackWithValidData
    Description: This test is meant to check the fractionalKnapsack function executes successfully when given valid weights, values and capacity. It checks the functionality of the function with normal inputs.
  Execution:
    Arrange: Create arrays for weights and values. Set a capacity which is within bounds.
    Act: Invoke the fractionalKnapsack function with the inputs.
    Assert: The output should be equal to the expected value calculated manually.
  Validation:
    The result should be the maximum value obtained with the given weights, values and capacity, as determined by the fractional knapsack problem. The test case checks that the algorithm is functioning correctly under normal conditions.
Scenario 2: Test with Zero Capacity
Details:
    TestName: testFractionalKnapsackWithZeroCapacity
    Description: This test checks how the function handles zero capacity, which is a boundary condition.
  Execution:
    Arrange: Use any set of weights and values. Set capacity to zero.
    Act: Invoke the fractionalKnapsack function with the inputs.
    Assert: The output must be 0, since no item can be included in the knapsack.
  Validation:
    If the knapsack's capacity is 0, then no item can fit, regardless of their weight or value. It ensures the function handles zero capacity correctly.
Scenario 3: Test with Negative Capacity
Details:
    TestName: testFractionalKnapsackWithNegativeCapacity
    Description: This test checks how the function handles negative capacity, which is an error condition.
  Execution:
    Arrange: Use any set of weights and values. Set capacity to a negative number.
    Act: Invoke the fractionalKnapsack function with the inputs.
    Assert: The output must throw an error or exception.
  Validation:
    It validates the function's error handling for invalid capacity. The capacity of a knapsack should not be negative; if it is, an error should be thrown.
Scenario 4: Test with Single Item that Fits Completely
Details:
    TestName: testFractionalKnapsackWithSingleItemThatFitsCompletely
    Description: This test verifies that the function correctly handles the case where there is a single item that completely fits the knapsack.
  Execution:
    Arrange: Create weights and values arrays with one element each. Set capacity equal to the weight.
    Act: Invoke the fractionalKnapsack function with the inputs.
    Assert: The output should be equal to the value of the single item.
  Validation:
    In this scenario, the single item fits exactly into the knapsack. The function should return the value of the single item in this case.
Scenario 5: Test with Single Item that Doesn't Fit Completely
Details:
    TestName: testFractionalKnapsackWithSingleItemThatDoesntFitCompletely
    Description: This scenario tests with a single item that doesn't fit completely in the knapsack.
  Execution:
    Arrange: Create weights and values arrays with one element each. The weight should be greater than the capacity.
    Act: Invoke the fractionalKnapsack function with the inputs.
    Assert: The output should be a fraction of the item's value, equal to the capacity-to-weight ratio multiplied by the value.
  Validation:
    The knapsack should be filled with the fraction of the item that fits, giving maximum value. It shouldn't accommodate items that will exceed its capacity. This will test if the function handles fractional value calculation properly.
Scenario 6: Test with All Zero Weights
Details:
    TestName: testFractionalKnapsackWithAllZeroWeights
    Description: This scenario examines the error handling for invalid weights, specifically all zero weights.
  Execution:
    Arrange: Create a zero weight array and an array of values. Any positive capacity.
    Act: Invoke the fractionalKnapsack function with the inputs.
    Assert: The function should throw an error or exception, as zero weights are invalid.
  Validation:
    This test is to ensure that the function correctly handles invalid data. Zero weights are anomalistic conditions since an item must have some weight.
"""
*/
// ********RoostGPT********
package com.thealgorithms.greedyalgorithms;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertThrows;
import org.junit.jupiter.api.Test;
import java.util.Arrays;
import java.util.Comparator;
import org.junit.jupiter.api.*;

@Tag("com.thealgorithms.sorts")
@Tag("com.thealgorithms.sorts.sort")
@Tag("com.thealgorithms.greedyalgorithms")
@Tag("com.thealgorithms.greedyalgorithms.fractionalKnapsack")
@Tag("roostTest1")
@Tag("roostTest2")
public class FractionalKnapsackFractionalKnapsackTest {

	@Test
	public void testFractionalKnapsackWithValidData() {
		int[] weight = { 10, 20, 30 };
		int[] value = { 60, 100, 120 };
		int capacity = 50;
		FractionalKnapsack knapsack = new FractionalKnapsack();
		int finalValue = knapsack.fractionalKnapsack(weight, value, capacity);
		assertEquals(240, finalValue);
	}

	@Test
	public void testFractionalKnapsackWithZeroCapacity() {
		int[] weight = { 10, 20, 30 };
		int[] value = { 60, 100, 120 };
		int capacity = 0;

		FractionalKnapsack knapsack = new FractionalKnapsack();
		int finalValue = knapsack.fractionalKnapsack(weight, value, capacity);
		assertEquals(0, finalValue);
	}

	@Test
	public void testFractionalKnapsackWithNegativeCapacity() {
		int[] weight = { 10, 20, 30 };
		int[] value = { 60, 100, 120 };
		int capacity = -10;

		FractionalKnapsack knapsack = new FractionalKnapsack();
		assertThrows(IllegalArgumentException.class, () -> knapsack.fractionalKnapsack(weight, value, capacity));
	}

	@Test
	public void testFractionalKnapsackWithSingleItemThatFitsCompletely() {
		int[] weight = { 10 };
		int[] value = { 60 };
		int capacity = 10;

		FractionalKnapsack knapsack = new FractionalKnapsack();
		int finalValue = knapsack.fractionalKnapsack(weight, value, capacity);
		assertEquals(60, finalValue);
	}

	@Test
	public void testFractionalKnapsackWithSingleItemThatDoesntFitCompletely() {
		int[] weight = { 10 };
		int[] value = { 60 };
		int capacity = 5;

		FractionalKnapsack knapsack = new FractionalKnapsack();
		int finalValue = knapsack.fractionalKnapsack(weight, value, capacity);
		assertEquals(30, finalValue);
	}

	@Test
	public void testFractionalKnapsackWithAllZeroWeights() {
		int[] weight = { 0, 0, 0 };
		int[] value = { 60, 100, 120 };
		int capacity = 10;

		FractionalKnapsack knapsack = new FractionalKnapsack();
		assertThrows(IllegalArgumentException.class, () -> knapsack.fractionalKnapsack(weight, value, capacity));
	}

}