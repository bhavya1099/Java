// ********RoostGPT********
/*
Test generated by RoostGPT for test java-customannotation-test using AI Type  and AI Model 
ROOST_METHOD_HASH=of_eb8138c6bc
ROOST_METHOD_SIG_HASH=of_7a04d5363c
Here are your existing test cases which we found out and are not considered for test generation:
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/datastructures/trees/ZigzagTraversalTest.java
Tests:
    "@Test
@Test
public void testSingleNodeTree() {
    final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] { 50 });
    assertEquals(List.of(List.of(50)), ZigzagTraversal.traverse(root));
}
"
    "@Test
/*
         1
        / \
       2   3
      /\   /\
     4  5 6  7
    */
@Test
public void testZigzagTraversalCompleteTree() {
    final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] { 1, 2, 3, 4, 5, 6, 7 });
    assertEquals(List.of(List.of(1), List.of(3, 2), List.of(4, 5, 6, 7)), ZigzagTraversal.traverse(root));
}
"
    "@Test
/*
         1
        / \
       2   3
      /\   /\
     4  5 6  7
        /  \
       8    9
    */
@Test
public void testZigzagTraversalDifferentHeight() {
    final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] { 1, 2, 3, 4, 5, 6, 7, null, null, 8, null, null, 9 });
    assertEquals(List.of(List.of(1), List.of(3, 2), List.of(4, 5, 6, 7), List.of(9, 8)), ZigzagTraversal.traverse(root));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/maths/GenericRootTest.java
Tests:
    "@Test
private static Stream<Arguments> tcStream() {
    return Stream.of(Arguments.of(0, 0), Arguments.of(1, 1), Arguments.of(12345, 6), Arguments.of(123, 6), Arguments.of(15937, 7), Arguments.of(222222, 3), Arguments.of(99999, 9));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/datastructures/crdt/ORSetTest.java
Tests:
    "@Test
@Test
void testElements() {
    ORSet<String> orSet = new ORSet<>();
    orSet.add("A");
    orSet.add("B");
    assertEquals(Set.of("A", "B"), orSet.elements());
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/others/TestPrintMatrixInSpiralOrder.java
Tests:
    "@Test
@Test
public void testOne() {
    int[][] matrix = { { 3, 4, 5, 6, 7 }, { 8, 9, 10, 11, 12 }, { 14, 15, 16, 17, 18 }, { 23, 24, 25, 26, 27 }, { 30, 31, 32, 33, 34 } };
    var printClass = new PrintAMatrixInSpiralOrder();
    List<Integer> res = printClass.print(matrix, matrix.length, matrix[0].length);
    List<Integer> list = List.of(3, 4, 5, 6, 7, 12, 18, 27, 34, 33, 32, 31, 30, 23, 14, 8, 9, 10, 11, 17, 26, 25, 24, 15, 16);
    assertIterableEquals(res, list);
}
"
    "@Test
@Test
public void testTwo() {
    int[][] matrix = { { 2, 2 } };
    var printClass = new PrintAMatrixInSpiralOrder();
    List<Integer> res = printClass.print(matrix, matrix.length, matrix[0].length);
    List<Integer> list = List.of(2, 2);
    assertIterableEquals(res, list);
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/maths/NumberOfDigitsTest.java
Tests:
    "@Test
private static Stream<Arguments> testCases() {
    final Integer[][] inputs = new Integer[][] { { 3, 100 }, { 1, 0 }, { 2, 12 }, { 3, 123 }, { 4, 1234 }, { 5, 12345 }, { 6, 123456 }, { 7, 1234567 }, { 8, 12345678 }, { 9, 123456789 }, { 9, 987654321 } };
    final IntFunction<Integer>[] methods = new IntFunction[] { NumberOfDigits::numberOfDigits, NumberOfDigits::numberOfDigitsFast, NumberOfDigits::numberOfDigitsFaster, NumberOfDigits::numberOfDigitsRecursion };
    return Stream.of(inputs).flatMap(input -> Stream.of(methods).map(method -> Arguments.of(input[0], input[1], method)));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/datastructures/trees/InorderTraversalTest.java
Tests:
    "@Test
/*
         1
        / \
       2   3
      /\   /\
     4  5 6  7
    */
@Test
public void testRecursiveInorder() {
    final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] { 1, 2, 3, 4, 5, 6, 7 });
    List<Integer> expected = List.of(4, 2, 5, 1, 6, 3, 7);
    assertEquals(expected, InorderTraversal.recursiveInorder(root));
    assertEquals(expected, InorderTraversal.iterativeInorder(root));
}
"
    "@Test
/*
         5
          \
           6
            \
             7
              \
               8
    */
@Test
public void testRecursiveInorderNonBalanced() {
    final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] { 5, null, 6, null, 7, null, 8 });
    List<Integer> expected = List.of(5, 6, 7, 8);
    assertEquals(expected, InorderTraversal.recursiveInorder(root));
    assertEquals(expected, InorderTraversal.iterativeInorder(root));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/maths/SquareFreeIntegerTest.java
Tests:
    "@Test
@Test
void testIsSquareFreeInteger() {
    // given
    List<Integer> listOfSquareFreeIntegers = List.of(1, 2, 3, 5, 6, 7, 10, 11, 13, 14, 15, 17, 19, 21, 22, 23, 26, 29, 30, 31, 33, 34, 35, 37, 38, 39, 41, 42, 43, 46, 47, 51, 53, 55, 57, 58, 59, 61, 62, 65, 66, 67, 69, 70, 71, 73, 74, 77, 78, 79, 82, 83, 85, 86, 87, 89, 91, 93, 94, 95, 97, 101, 102, 103, 105, 106, 107, 109, 110, 111, 113, 114, 115, 118, 119, 122, 123, 127, 129, 130, 131, 133, 134, 137, 138, 139, 141, 142, 143, 145, 146, 149, 151, 154, 155, 157, 158, 159, 161, 163, 165, 166, 167, 170, 173, 174, 177, 178, 179, 181, 182, 183, 185, 186, 187, 190, 191, 193, 194, 195, 197, 199, 201, 202, 203, 205, 206, 209, 210, 211, 213, 214, 215, 217, 218, 219, 221, 222, 223, 226, 227, 229, 230, 231, 233, 235, 237, 238, 239, 241, 246, 247, 249, 251, 253, 254, 255, 257, 258, 259, 262, 263, 265, 266, 267, 269, 271, 273, 274, 277, 278, 281, 282, 283, 285, 286, 287, 290, 291, 293, 295, 298, 299, 301, 302, 303, 305, 307, 309, 310, 311, 313, 314, 317, 318, 319, 321, 322, 323, 326, 327, 329, 330, 331, 334, 335, 337, 339, 341, 345, 346, 347, 349, 353, 354, 355, 357, 358, 359, 362, 365, 366, 367, 370, 371, 373, 374, 377, 379, 381, 382, 383, 385, 386, 389, 390, 391, 393, 394, 395, 397, 398, 399, 401, 402, 403, 406, 407, 409, 410, 411, 413, 415, 417, 418, 419, 421, 422, 426, 427, 429, 430, 431, 433, 434, 435, 437, 438, 439, 442, 443, 445, 446, 447, 449, 451, 453, 454, 455, 457, 458, 461, 462, 463, 465, 466, 467, 469, 470, 471, 473, 474, 478, 479, 481, 482, 483, 485, 487, 489, 491, 493, 494, 497, 498, 499, 501, 502, 503, 505, 506, 509, 510, 511, 514, 515, 517, 518, 519, 521, 523, 526, 527, 530, 533, 534, 535, 537, 538, 541, 542, 543, 545, 546, 547, 551, 553, 554, 555, 557, 559, 561, 562, 563, 565, 566, 569, 570, 571, 573, 574, 577, 579, 581, 582, 583, 586, 587, 589, 590, 591, 593, 595, 597, 598, 599, 601, 602, 606, 607, 609, 610, 611, 613, 614, 615, 617, 618, 619, 622, 623, 626, 627, 629, 631, 633, 634, 635, 638, 641, 642, 643, 645, 646, 647, 649, 651, 653, 654, 655, 658, 659, 661, 662, 663, 665, 667, 669, 670, 671, 673, 674, 677, 678, 679, 681, 682, 683, 685, 687, 689, 690, 691, 694, 695, 697, 698, 699, 701, 703, 705, 706, 707, 709, 710, 713, 714, 715, 717, 718, 719, 721, 723, 727, 730, 731, 733, 734, 737, 739, 741, 742, 743, 745, 746, 749, 751, 753, 754, 755, 757, 758, 759, 761, 762, 763, 766, 767, 769, 770, 771, 773, 777, 778, 779, 781, 782, 785, 786, 787, 789, 790, 791, 793, 794, 795, 797, 798, 799, 802, 803, 805, 806, 807, 809, 811, 813, 814, 815, 817, 818, 821, 822, 823, 826, 827, 829, 830, 831, 834, 835, 838, 839, 842, 843, 849, 851, 853, 854, 857, 858, 859, 861, 862, 863, 865, 866, 869, 870, 871, 874, 877, 878, 879, 881, 883, 885, 886, 887, 889, 890, 893, 894, 895, 897, 898, 899, 901, 902, 903, 905, 906, 907, 910, 911, 913, 914, 915, 917, 919, 921, 922, 923, 926, 929, 930, 933, 934, 935, 937, 938, 939, 941, 942, 943, 946, 947, 949, 951, 953, 955, 957, 958, 959, 962, 965, 966, 967, 969, 970, 971, 973, 974, 977, 978, 979, 982, 983, 985, 986, 987, 989, 991, 993, 994, 995, 997, 998, 1001, 1002, 1003, 1005, 1006, 1007, 1009, 1010, 1011, 1013, 1015, 1018, 1019, 1021, 1022, 1023, 1027, 1030, 1031, 1033, 1034, 1037, 1038, 1039, 1041, 1042, 1043, 1045, 1046, 1047, 1049, 1051, 1054, 1055, 1057, 1059, 1061, 1063, 1065, 1066, 1067, 1069, 1070, 1073, 1074, 1077, 1079, 1081, 1082, 1085, 1086, 1087, 1090, 1091, 1093, 1094, 1095, 1097, 1099, 1101, 1102, 1103, 1105, 1106, 1109, 1110, 1111, 1113, 1114, 1115, 1117, 1118, 1119, 1121, 1122, 1123, 1126, 1129, 1130, 1131, 1133, 1135, 1137, 1138, 1139, 1141, 1142, 1145, 1146, 1147, 1149, 1151, 1153, 1154, 1155, 1157, 1158, 1159, 1162, 1163, 1165, 1166, 1167, 1169, 1171, 1173, 1174, 1177, 1178, 1181, 1182, 1185, 1186, 1187, 1189, 1190, 1191, 1193, 1194, 1195, 1198, 1199, 1201, 1202, 1203, 1205, 1207, 1209, 1211, 1213, 1214, 1217, 1218, 1219, 1221, 1222, 1223, 1226, 1227, 1229, 1230, 1231, 1234, 1235, 1237, 1238, 1239, 1241, 1243, 1245, 1246, 1247, 1249, 1253, 1254, 1255, 1257, 1258, 1259, 1261, 1262, 1263, 1265, 1266, 1267, 1270, 1271, 1273, 1277, 1279, 1281, 1282, 1283, 1285, 1286, 1289, 1290, 1291, 1293, 1294, 1295, 1297, 1298, 1299, 1301, 1302, 1303, 1306, 1307, 1309, 1310, 1311, 1313, 1315, 1317, 1318, 1319, 1321, 1322, 1326, 1327, 1329, 1330, 1333, 1334, 1335, 1337, 1338, 1339, 1342, 1343, 1345, 1346, 1347, 1349, 1351, 1353, 1354, 1355, 1357, 1358, 1361, 1362, 1363, 1365, 1366, 1367, 1370, 1371, 1373, 1374, 1378, 1379, 1381, 1382, 1383, 1385, 1387, 1389, 1390, 1391, 1393, 1394, 1397, 1398, 1399, 1401, 1402, 1403, 1405, 1406, 1407, 1409, 1410, 1411, 1414, 1415, 1417, 1418, 1419, 1423, 1426, 1427, 1429, 1430, 1433, 1434, 1435, 1437, 1438, 1439, 1441, 1442, 1443, 1446, 1447, 1451, 1453, 1454, 1455, 1457, 1459, 1461, 1462, 1463, 1465, 1466, 1469, 1471, 1473, 1474, 1477, 1478, 1479, 1481, 1482, 1483, 1486, 1487, 1489, 1490, 1491, 1493, 1495, 1497, 1498, 1499, 1501, 1502, 1505, 1506, 1507, 1509, 1510, 1511, 1513, 1514, 1515, 1517, 1518, 1522, 1523, 1526, 1527, 1529, 1531, 1533, 1534, 1535, 1537, 1538, 1541, 1542, 1543, 1545, 1546, 1547, 1549, 1551, 1553, 1554, 1555, 1558, 1559, 1561, 1562, 1563, 1565, 1567, 1569, 1570, 1571, 1574, 1577, 1578, 1579, 1581, 1582, 1583, 1585, 1586, 1589, 1590, 1591, 1594, 1595, 1597, 1598, 1599, 1601, 1603, 1605, 1606, 1607, 1609, 1610, 1613, 1614, 1615, 1618, 1619, 1621, 1622, 1623, 1626, 1627, 1630, 1631, 1633, 1634, 1635, 1637, 1639, 1641, 1642, 1643, 1645, 1646, 1649, 1651, 1653, 1654, 1655, 1657, 1658, 1659, 1661, 1662, 1663, 1667, 1669, 1670, 1671, 1673, 1677, 1678, 1679, 1685, 1686, 1687, 1689, 1691, 1693, 1695, 1697, 1698, 1699, 1702, 1703, 1705, 1706, 1707, 1709, 1711, 1713, 1714, 1717, 1718, 1721, 1722, 1723, 1726, 1727, 1729, 1730, 1731, 1733, 1735, 1738, 1739, 1741, 1742, 1743, 1745, 1747, 1749, 1751, 1753, 1754, 1757, 1758, 1759, 1761, 1762, 1763, 1765, 1766, 1767, 1769, 1770, 1771, 1774, 1777, 1778, 1779, 1781, 1783, 1785, 1786, 1787, 1789, 1790, 1793, 1794, 1795, 1797, 1798, 1799, 1801, 1802, 1803, 1806, 1807, 1810, 1811, 1814, 1817, 1819, 1821, 1822, 1823, 1826, 1829, 1830, 1831, 1833, 1834, 1835, 1837, 1838, 1839, 1841, 1842, 1843, 1846, 1847, 1851, 1853, 1855, 1857, 1858, 1861, 1865, 1866, 1867, 1869, 1870, 1871, 1873, 1874, 1877, 1878, 1879, 1882, 1883, 1885, 1886, 1887, 1889, 1891, 1893, 1894, 1895, 1897, 1898, 1901, 1902, 1903, 1905, 1906, 1907, 1909, 1910, 1913, 1914, 1915, 1918, 1919, 1921, 1923, 1927, 1929, 1930, 1931, 1933, 1934, 1937, 1938, 1939, 1941, 1942, 1943, 1945, 1946, 1947, 1949, 1951, 1954, 1955, 1957, 1958, 1959, 1961, 1963, 1965, 1966, 1967, 1969, 1970, 1973, 1974, 1977, 1978, 1979, 1981, 1982, 1983, 1985, 1986, 1987, 1990, 1991, 1993, 1994, 1995, 1997, 1999, 2001, 2002, 2003, 2005, 2006, 2010, 2011, 2013, 2014, 2015, 2017, 2018, 2019, 2021, 2022, 2026, 2027, 2029, 2030, 2031, 2033, 2035, 2037, 2038, 2039, 2041, 2042, 2045, 2046, 2047, 2049, 2051, 2053, 2054, 2055, 2059, 2062, 2063, 2065, 2066, 2067, 2069, 2071, 2073, 2074, 2077, 2078, 2081, 2082, 2083, 2085, 2086, 2087, 2089, 2090, 2091, 2093, 2094, 2095, 2098, 2099, 2101, 2102, 2103, 2105, 2109, 2110, 2111, 2113, 2114, 2117, 2118, 2119, 2121, 2122, 2123, 2126, 2127, 2129, 2130, 2131, 2134, 2135, 2137, 2138, 2139, 2141, 2143, 2145, 2146, 2147, 2149, 2153, 2154, 2155, 2157, 2158, 2159, 2161, 2162, 2163, 2165, 2167, 2170, 2171, 2173, 2174, 2177, 2179, 2181, 2182, 2183, 2185, 2186, 2189, 2190, 2191, 2193, 2194, 2195, 2198, 2199, 2201, 2202, 2203, 2206, 2207, 2210, 2211, 2213, 2215, 2217, 2218, 2219, 2221, 2222, 2226, 2227, 2229, 2230, 2231, 2233, 2234, 2235, 2237, 2238, 2239, 2242, 2243, 2245, 2246, 2247, 2249, 2251, 2253, 2255, 2257, 2258, 2261, 2262, 2263, 2265, 2266, 2267, 2269, 2270, 2271, 2273, 2274, 2278, 2279, 2281, 2282, 2283, 2285, 2287, 2289, 2290, 2291, 2293, 2294, 2297, 2298, 2301, 2302, 2305, 2306, 2307, 2309, 2310, 2311, 2314, 2315, 2317, 2318, 2319, 2321, 2323, 2326, 2327, 2329, 2330, 2333, 2334, 2335, 2337, 2338, 2339, 2341, 2342, 2343, 2345, 2346, 2347, 2351, 2353, 2354, 2355, 2357, 2359, 2361, 2362, 2363, 2365, 2369, 2370, 2371, 2373, 2374, 2377, 2378, 2379, 2381, 2382, 2383, 2386, 2387, 2389, 2390, 2391, 2393, 2395, 2397, 2398, 2399, 2402, 2405, 2406, 2407, 2409, 2410, 2411, 2413, 2414, 2415, 2417, 2418, 2419, 2422, 2423, 2426, 2427, 2429, 2431, 2433, 2434, 2435, 2437, 2438, 2441, 2442, 2443, 2445, 2446, 2447, 2449, 2451, 2453, 2454, 2455, 2458, 2459, 2461, 2462, 2463, 2465, 2467, 2469, 2470, 2471, 2473, 2474, 2477, 2478, 2479, 2481, 2482, 2483, 2485, 2486, 2487, 2489, 2490, 2491, 2494, 2495, 2497, 2498);
    for (int i = 1; i <= 2500; i++) {
        // when
        boolean isNumberSquareFree = SquareFreeInteger.isSquareFreeInteger(i);
        boolean isNumberPresentInList = listOfSquareFreeIntegers.contains(i);
        // then
        assertEquals(isNumberSquareFree, isNumberPresentInList);
    }
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/datastructures/trees/LevelOrderTraversalTest.java
Tests:
    "@Test
@Test
public void testSingleNodeTree() {
    final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] { 50 });
    assertEquals(List.of(List.of(50)), LevelOrderTraversal.traverse(root));
}
"
    "@Test
/*
         1
        / \
       2   3
      /\   /\
     4  5 6  7
    */
@Test
public void testLevelOrderTraversalCompleteTree() {
    final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] { 1, 2, 3, 4, 5, 6, 7 });
    assertEquals(List.of(List.of(1), List.of(2, 3), List.of(4, 5, 6, 7)), LevelOrderTraversal.traverse(root));
}
"
    "@Test
/*
         1
        / \
       2   3
      /\   /\
     4  5 6  7
        /  \
       8    9
    */
@Test
public void testLevelOrderTraversalDifferentHeight() {
    final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] { 1, 2, 3, 4, 5, 6, 7, null, null, 8, null, null, 9 });
    assertEquals(List.of(List.of(1), List.of(2, 3), List.of(4, 5, 6, 7), List.of(8, 9)), LevelOrderTraversal.traverse(root));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/maths/FindMaxRecursionTest.java
Tests:
    "@Test
private static Stream<Arguments> inputStream() {
    return Stream.of(Arguments.of(5, new int[] { 5, 5, 5, 5, 5 }), Arguments.of(0, new int[] { -1, 0 }), Arguments.of(-1, new int[] { -10, -9, -8, -7, -6, -5, -4, -3, -2, -1 }), Arguments.of(9, new int[] { 3, -2, 3, 9, -4, -4, 8 }), Arguments.of(3, new int[] { 3 }));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/backtracking/ParenthesesGeneratorTest.java
Tests:
    "@Test
private static Stream<Arguments> regularInputStream() {
    return Stream.of(Arguments.of(0, List.of("")), Arguments.of(1, List.of("()")), Arguments.of(2, List.of("(())", "()()")), Arguments.of(3, List.of("((()))", "(()())", "(())()", "()(())", "()()()")), Arguments.of(4, List.of("(((())))", "((()()))", "((())())", "((()))()", "(()(()))", "(()()())", "(()())()", "(())(())", "(())()()", "()((()))", "()(()())", "()(())()", "()()(())", "()()()()")));
}
"
    "@Test
private static Stream<Arguments> negativeInputStream() {
    return Stream.of(Arguments.of(-1), Arguments.of(-5), Arguments.of(-10));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/backtracking/SubsequenceFinderTest.java
Tests:
    "@Test
static Stream<TestCase> getTestCases() {
    return Stream.of(new TestCase(new ArrayList<>(), List.of(List.of())), new TestCase(List.of(1, 2), List.of(List.of(), List.of(2), List.of(1), List.of(1, 2))), new TestCase(List.of("A", "B", "C"), List.of(List.of(), List.of("C"), List.of("B"), List.of("B", "C"), List.of("A"), List.of("A", "C"), List.of("A", "B"), List.of("A", "B", "C"))), new TestCase(List.of(1, 2, 3), List.of(List.of(), List.of(3), List.of(2), List.of(2, 3), List.of(1), List.of(1, 3), List.of(1, 2), List.of(1, 2, 3))), new TestCase(List.of(2, 2), List.of(List.of(), List.of(2), List.of(2), List.of(2, 2))));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/maths/MatrixRankTest.java
Tests:
    "@Test
private static Stream<Arguments> validInputStream() {
    return Stream.of(Arguments.of(3, new double[][] { { 1, 0, 0 }, { 0, 1, 0 }, { 0, 0, 1 } }), Arguments.of(0, new double[][] { { 0, 0, 0 }, { 0, 0, 0 }, { 0, 0, 0 } }), Arguments.of(1, new double[][] { { 1 } }), Arguments.of(2, new double[][] { { 1, 2 }, { 3, 4 } }), Arguments.of(2, new double[][] { { 3, -1, 2 }, { -3, 1, 2 }, { -6, 2, 4 } }), Arguments.of(3, new double[][] { { 2, 3, 0, 1 }, { 1, 0, 1, 2 }, { -1, 1, 1, -2 }, { 1, 5, 3, -1 } }), Arguments.of(1, new double[][] { { 1, 2, 3 }, { 3, 6, 9 } }), Arguments.of(2, new double[][] { { 0.25, 0.5, 0.75, 2 }, { 1.5, 3, 4.5, 6 }, { 1, 2, 3, 4 } }));
}
"
    "@Test
private static Stream<Arguments> invalidInputStream() {
    return // jagged array
    Stream.// jagged array
    of(// jagged array
    Arguments.of((Object) new double[][] { { 1, 2 }, { 10 }, { 100, 200, 300 } }), // empty matrix
    Arguments.of((Object) new double[][] {}), // empty row
    Arguments.of((Object) new double[][] { {}, {} }), // null matrix
    Arguments.of((Object) null), // null row
    Arguments.of((Object) new double[][] { { 1, 2 }, null }));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/maths/SumOfDigitsTest.java
Tests:
    "@Test
private static Stream<Arguments> testCases() {
    return Stream.of(Arguments.of(0, 0), Arguments.of(1, 1), Arguments.of(15, 12345), Arguments.of(6, -123), Arguments.of(1, -100000), Arguments.of(8, 512));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/datastructures/trees/PreOrderTraversalTest.java
Tests:
    "@Test
/*
         1
        / \
       2   3
      /\   /\
     4  5 6  7
    */
@Test
public void testRecursivePreOrder() {
    final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] { 1, 2, 3, 4, 5, 6, 7 });
    List<Integer> expected = List.of(1, 2, 4, 5, 3, 6, 7);
    assertEquals(expected, PreOrderTraversal.recursivePreOrder(root));
    assertEquals(expected, PreOrderTraversal.iterativePreOrder(root));
}
"
    "@Test
/*
         5
          \
           6
            \
             7
              \
               8
    */
@Test
public void testRecursivePreOrderNonBalanced() {
    final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] { 5, null, 6, null, 7, null, 8 });
    List<Integer> expected = List.of(5, 6, 7, 8);
    assertEquals(expected, PreOrderTraversal.recursivePreOrder(root));
    assertEquals(expected, PreOrderTraversal.iterativePreOrder(root));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/searches/DepthFirstSearchTest.java
Tests:
    "@Test
@Test
public void testSearchRoot() {
    Integer expectedValue = 1;
    List<Integer> expectedPath = List.of(1);
    // check value
    Optional<Node<Integer>> value = dfs.recursiveSearch(root, expectedValue);
    assertEquals(expectedValue, value.orElse(new Node<>(null)).getValue());
    // check path
    assertArrayEquals(expectedPath.toArray(), dfs.getVisited().toArray());
}
"
    "@Test
@Test
public void testSearch4() {
    Integer expectedValue = 4;
    List<Integer> expectedPath = List.of(1, 2, 5, 6, 3, 4);
    // check value
    Optional<Node<Integer>> value = dfs.recursiveSearch(root, expectedValue);
    assertEquals(expectedValue, value.orElse(new Node<>(null)).getValue());
    // check path
    assertArrayEquals(expectedPath.toArray(), dfs.getVisited().toArray());
}
"
    "@Test
@Test
void testSearchValueThatNotExists() {
    List<Integer> expectedPath = List.of(1, 2, 5, 6, 3, 4);
    var value = dfs.recursiveSearch(root, 10);
    // check that the value is empty because it's not exists in the tree
    assertTrue(value.isEmpty());
    // check path is the whole list
    assertArrayEquals(expectedPath.toArray(), dfs.getVisited().toArray());
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/strings/AhoCorasickTest.java
Tests:
    "@Test
/**
 * Test searching for multiple patterns in the input text.
 * The expected results are defined for each pattern.
 */
@Test
void testSearch() {
    // Define the expected results for each pattern
    final var expected = Map.of("ACC", new ArrayList<>(Arrays.asList()), "ATC", new ArrayList<>(Arrays.asList(2)), "CAT", new ArrayList<>(Arrays.asList(1)), "GCG", new ArrayList<>(Arrays.asList()), "C", new ArrayList<>(Arrays.asList(1, 4)), "T", new ArrayList<>(Arrays.asList(3)));
    assertEquals(expected, AhoCorasick.search(text, patterns));
}
"
    "@Test
/**
 * Test searching for patterns that are not present in the input text.
 * The result should be an empty list for each pattern.
 */
@Test
void testPatternNotFound() {
    // Define patterns that are not present in the text
    final var searchPatterns = new String[] { "XYZ", "123" };
    final var expected = Map.of("XYZ", new ArrayList<Integer>(), "123", new ArrayList<Integer>());
    assertEquals(expected, AhoCorasick.search(text, searchPatterns));
}
"
    "@Test
/**
 * Test searching for patterns that start at the beginning of the input text.
 * The expected position for each pattern is 0.
 */
@Test
void testPatternAtBeginning() {
    // Define patterns that start at the beginning of the text
    final var searchPatterns = new String[] { "GC", "GCA", "GCAT" };
    final var expected = Map.of("GC", new ArrayList<Integer>(Arrays.asList(0)), "GCA", new ArrayList<Integer>(Arrays.asList(0)), "GCAT", new ArrayList<Integer>(Arrays.asList(0)));
    assertEquals(expected, AhoCorasick.search(text, searchPatterns));
}
"
    "@Test
/**
 * Test searching for patterns that end at the end of the input text.
 * The expected positions are 4, 3, and 2 for the patterns.
 */
@Test
void testPatternAtEnd() {
    // Define patterns that end at the end of the text
    final var searchPatterns = new String[] { "CG", "TCG", "ATCG" };
    final var expected = Map.of("CG", new ArrayList<Integer>(Arrays.asList(4)), "TCG", new ArrayList<Integer>(Arrays.asList(3)), "ATCG", new ArrayList<Integer>(Arrays.asList(2)));
    assertEquals(expected, AhoCorasick.search(text, searchPatterns));
}
"
    "@Test
/**
 * Test searching for patterns with multiple occurrences in the input text.
 * The expected sizes are 1 and 1, and the expected positions are 2 and 3
 * for the patterns "AT" and "T" respectively.
 */
@Test
void testMultipleOccurrencesOfPattern() {
    // Define patterns with multiple occurrences in the text
    final var searchPatterns = new String[] { "AT", "T" };
    final var expected = Map.of("AT", new ArrayList<Integer>(Arrays.asList(2)), "T", new ArrayList<Integer>(Arrays.asList(3)));
    assertEquals(expected, AhoCorasick.search(text, searchPatterns));
}
"
    "@Test
/**
 * Test searching for patterns in a case-insensitive manner.
 * The search should consider patterns regardless of their case.
 */
@Test
void testCaseInsensitiveSearch() {
    // Define patterns with different cases
    final var searchPatterns = new String[] { "gca", "aTc", "C" };
    final var expected = Map.of("gca", new ArrayList<Integer>(), "aTc", new ArrayList<Integer>(), "C", new ArrayList<Integer>(Arrays.asList(1, 4)));
    assertEquals(expected, AhoCorasick.search(text, searchPatterns));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/dynamicprogramming/LevenshteinDistanceTests.java
Tests:
    "@Test
private static Stream<Arguments> testCases() {
    final Object[][] testData = { { 0, "", "" }, { 0, "Hello, World!", "Hello, World!" }, { 4, "", "Rust" }, { 3, "horse", "ros" }, { 6, "tan", "elephant" }, { 8, "execute", "intention" }, { 1, "a", "b" }, { 1, "a", "aa" }, { 1, "a", "" }, { 1, "a", "ab" }, { 1, "a", "ba" }, { 2, "a", "bc" }, { 2, "a", "cb" } };
    final List<ToIntBiFunction<String, String>> methods = Arrays.asList(LevenshteinDistance::naiveLevenshteinDistance, LevenshteinDistance::optimizedLevenshteinDistance);
    return Stream.of(testData).flatMap(input -> methods.stream().map(method -> Arguments.of(input[0], input[1], input[2], method)));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/maths/SecondMinMaxTest.java
Tests:
    "@Test
private static Stream<Arguments> inputStream() {
    return Stream.of(Arguments.of(new TestCase(new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }, 2, 9)), Arguments.of(new TestCase(new int[] { 5, 4, 5, 5, 5 }, 5, 4)), Arguments.of(new TestCase(new int[] { -1, 0 }, 0, -1)), Arguments.of(new TestCase(new int[] { -10, -9, -8, -7, -6, -5, -4, -3, -2, -1 }, -9, -2)), Arguments.of(new TestCase(new int[] { 3, -2, 3, 9, -4, -4, 8 }, -2, 8)));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/datastructures/trees/VerticalOrderTraversalTest.java
Tests:
    "@Test
@Test
public void testSingleNodeTree() {
    final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] { 50 });
    assertEquals(List.of(50), VerticalOrderTraversal.verticalTraversal(root));
}
"
    "@Test
/*
         1
        / \
       2   3
      /\   /\
     4  5 6  7
    */
@Test
public void testVerticalTraversalCompleteTree() {
    final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] { 1, 2, 3, 4, 5, 6, 7 });
    assertEquals(List.of(4, 2, 1, 5, 6, 3, 7), VerticalOrderTraversal.verticalTraversal(root));
}
"
    "@Test
/*
         1
        / \
       2   3
      /\   /\
     4  5 6  7
        /  \
       8    9
    */
@Test
public void testVerticalTraversalDifferentHeight() {
    final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] { 1, 2, 3, 4, 5, 6, 7, null, null, 8, null, null, 9 });
    assertEquals(List.of(4, 2, 8, 1, 5, 6, 3, 9, 7), VerticalOrderTraversal.verticalTraversal(root));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/maths/ModeTest.java
Tests:
    "@Test
private static Stream<Arguments> tcStream() {
    return Stream.of(Arguments.of(null, new int[] {}), Arguments.of(new int[] { 5 }, new int[] { 5 }), Arguments.of(new int[] { 1, 2, 3, 4, 5 }, new int[] { 1, 2, 3, 4, 5 }), Arguments.of(new int[] { 1, 2, 3, 4, 5 }, new int[] { 5, 4, 3, 2, 1 }), Arguments.of(new int[] { 7 }, new int[] { 7, 9, 9, 4, 5, 6, 7, 7, 8 }), Arguments.of(new int[] { 7, 9 }, new int[] { 7, 9, 9, 4, 5, 6, 7, 7, 9 }));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/datastructures/trees/PostOrderTraversalTest.java
Tests:
    "@Test
/*
         1
        / \
       2   3
      /\   /\
     4  5 6  7
    */
@Test
public void testPostOrder() {
    final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] { 1, 2, 3, 4, 5, 6, 7 });
    List<Integer> expected = List.of(4, 5, 2, 6, 7, 3, 1);
    assertEquals(expected, PostOrderTraversal.recursivePostOrder(root));
    assertEquals(expected, PostOrderTraversal.iterativePostOrder(root));
}
"
    "@Test
/*
         5
          \
           6
            \
             7
              \
               8
    */
@Test
public void testPostOrderNonBalanced() {
    final BinaryTree.Node root = TreeTestUtils.createTree(new Integer[] { 5, null, 6, null, 7, null, 8 });
    List<Integer> expected = List.of(8, 7, 6, 5);
    assertEquals(expected, PostOrderTraversal.recursivePostOrder(root));
    assertEquals(expected, PostOrderTraversal.iterativePostOrder(root));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/maths/CollatzConjectureTest.java
Tests:
    "@Test
@Test
void collatzConjecture() {
    final List<Integer> expected = List.of(35, 106, 53, 160, 80, 40, 20, 10, 5, 16, 8, 4, 2, 1);
    assertIterableEquals(expected, cConjecture.collatzConjecture(35));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/sorts/SortingAlgorithmTest.java
Tests:
    "@Test
@Test
void shouldAcceptWhenSingleValuedListIsPassed() {
    List<Integer> list = List.of(2);
    List<Integer> expected = List.of(2);
    List<Integer> sorted = getSortAlgorithm().sort(list);
    assertIterableEquals(expected, sorted);
}
"
    "@Test
@Test
void shouldAcceptWhenArrayWithAllPositiveValuesIsPassed() {
    List<Integer> list = List.of(60, 7, 55, 9, 999, 3);
    List<Integer> expected = List.of(3, 7, 9, 55, 60, 999);
    List<Integer> sorted = getSortAlgorithm().sort(list);
    assertIterableEquals(expected, sorted);
}
"
    "@Test
@Test
void shouldAcceptWhenListWithAllNegativeValuesIsPassed() {
    List<Integer> list = List.of(-60, -7, -55, -9, -999, -3);
    List<Integer> expected = List.of(-999, -60, -55, -9, -7, -3);
    List<Integer> sorted = getSortAlgorithm().sort(list);
    assertIterableEquals(expected, sorted);
}
"
    "@Test
@Test
void shouldAcceptWhenListWithRealNumberValuesIsPassed() {
    List<Integer> list = List.of(60, -7, 55, 9, -999, -3);
    List<Integer> expected = List.of(-999, -7, -3, 9, 55, 60);
    List<Integer> sorted = getSortAlgorithm().sort(list);
    assertIterableEquals(expected, sorted);
}
"
    "@Test
@Test
void shouldAcceptWhenListWithDuplicateValueIsPassed() {
    List<Integer> list = List.of(60, 7, 55, 55, 999, 3);
    List<Integer> expected = List.of(3, 7, 55, 55, 60, 999);
    List<Integer> sorted = getSortAlgorithm().sort(list);
    assertIterableEquals(expected, sorted);
}
"
    "@Test
@Test
void shouldAcceptWhenStringValueListIsPassed() {
    List<String> list = List.of("z", "a", "x", "b", "y");
    List<String> expected = List.of("a", "b", "x", "y", "z");
    List<String> sorted = getSortAlgorithm().sort(list);
    assertIterableEquals(expected, sorted);
}
"
    "@Test
@Test
void shouldAcceptWhenRandomListIsPassed() {
    int randomSize = SortUtilsRandomGenerator.generateInt(10_000);
    Double[] array = SortUtilsRandomGenerator.generateArray(randomSize);
    List<Double> list = List.of(array);
    List<Double> sorted = getSortAlgorithm().sort(list);
    assertTrue(SortUtils.isSorted(sorted));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/strings/ReverseWordsInStringTest.java
Tests:
    "@Test
private static Stream<Arguments> inputStream() {
    return Stream.of(Arguments.of("blue is Sky", "Sky is blue"), Arguments.of("blue is Sky", "Sky \n is \t \n  blue "), Arguments.of("", ""), Arguments.of("", "    "), Arguments.of("", "\t"));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/searches/BreadthFirstSearchTest.java
Tests:
    "@Test
@Test
public void testSearchRoot() {
    String expectedValue = "A";
    List<String> expectedPath = List.of("A");
    // check value
    Optional<Node<String>> value = bfs.search(root, expectedValue);
    assertEquals(expectedValue, value.orElse(new Node<>("")).getValue());
    // check path
    assertArrayEquals(expectedPath.toArray(), bfs.getVisited().toArray());
}
"
    "@Test
@Test
public void testSearchF() {
    String expectedValue = "F";
    List<String> expectedPath = List.of("A", "B", "C", "D", "E", "F");
    // check value
    Optional<Node<String>> value = Optional.of(bfs.search(root, expectedValue).orElse(new Node<>(null)));
    assertEquals(expectedValue, value.get().getValue());
    // check path
    assertArrayEquals(expectedPath.toArray(), bfs.getVisited().toArray());
}
"
    "@Test
@Test
void testSearchNull() {
    List<String> expectedPath = List.of("A", "B", "C", "D", "E", "F");
    Optional<Node<String>> node = bfs.search(root, null);
    // check value
    assertTrue(node.isEmpty());
    // check path
    assertArrayEquals(expectedPath.toArray(), bfs.getVisited().toArray());
}
"
    "@Test
@Test
void testSearchValueThatNotExists() {
    List<String> expectedPath = List.of("A", "B", "C", "D", "E", "F");
    var value = bfs.search(root, "Z");
    // check that the value is empty because it's not exists in the tree
    assertTrue(value.isEmpty());
    // check path is the whole list
    assertArrayEquals(expectedPath.toArray(), bfs.getVisited().toArray());
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/maths/AmicableNumberTest.java
Tests:
    "@Test
@Test
public void testShouldFindAllAmicableNumbersInRange() {
    // given
    var expectedResult = Set.of(Pair.of(220, 284), Pair.of(1184, 1210), Pair.of(2620, 2924));
    // when
    Set<Pair<Integer, Integer>> result = AmicableNumber.findAllInRange(1, 3000);
    // then
    Assertions.assertTrue(result.containsAll(expectedResult));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/maths/FindMaxTest.java
Tests:
    "@Test
private static Stream<Arguments> inputStream() {
    return Stream.of(Arguments.of(10, new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }), Arguments.of(5, new int[] { 5, 5, 5, 5, 5 }), Arguments.of(0, new int[] { -1, 0 }), Arguments.of(-1, new int[] { -10, -9, -8, -7, -6, -5, -4, -3, -2, -1 }), Arguments.of(9, new int[] { 3, -2, 3, 9, -4, -4, 8 }));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/others/BoyerMooreTest.java
Tests:
    "@Test
private static Stream<Arguments> inputStreamWithExistingMajority() {
    return Stream.of(Arguments.of(5, new int[] { 5, 5, 5, 2 }), Arguments.of(10, new int[] { 10, 10, 20 }), Arguments.of(10, new int[] { 10, 20, 10 }), Arguments.of(10, new int[] { 20, 10, 10 }), Arguments.of(4, new int[] { 1, 4, 2, 4, 4, 5, 4 }), Arguments.of(-1, new int[] { -1 }));
}
"
    "@Test
private static Stream<Arguments> inputStreamWithoutMajority() {
    return Stream.of(Arguments.of(new int[] { 10, 10, 20, 20, 30, 30 }), Arguments.of(new int[] { 10, 20, 30, 40, 50 }), Arguments.of(new int[] { 1, 2 }), Arguments.of(new int[] {}));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/maths/FindMinTest.java
Tests:
    "@Test
private static Stream<Arguments> inputStream() {
    return Stream.of(Arguments.of(1, new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }), Arguments.of(5, new int[] { 5, 5, 5, 5, 5 }), Arguments.of(0, new int[] { 0, 192, 384, 576 }), Arguments.of(-1, new int[] { -1, 2, 5, 10 }), Arguments.of(-10, new int[] { -10, -9, -8, -7, -6, -5, -4, -3, -2, -1 }), Arguments.of(-4, new int[] { 4, -3, 8, 9, -4, -4, 10 }));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/misc/TwoSumProblemTest.java
Tests:
    "@Test
@Test
void testTwoSumExists() {
    final int[] values = new int[] { 2, 7, 11, 15 };
    final int target = 9;
    // values[0] + values[1] = 2 + 7 = 9
    final var expected = Pair.of(0, 1);
    assertEquals(expected, TwoSumProblem.twoSum(values, target).get());
}
"
    "@Test
@Test
void testTwoSumMultipleSolutions() {
    final int[] values = { 3, 3 };
    final int target = 6;
    // values[0] + values[1] = 3 + 3 = 6
    final var expected = Pair.of(0, 1);
    assertEquals(expected, TwoSumProblem.twoSum(values, target).get());
}
"
    "@Test
@Test
void testTwoSumMultipleSolution() {
    final int[] values = { 3, 4, 3, 3 };
    final int target = 6;
    // values[0] + values[2] = 3 + 3 = 6
    final var expected = Pair.of(0, 2);
    assertEquals(expected, TwoSumProblem.twoSum(values, target).get());
}
"
    "@Test
@Test
void testTwoSumNegativeNumbers() {
    final int[] values = { -1, -2, -3, -4, -5 };
    final int target = -8;
    // values[2] + values[4] = -3 + (-5) = -8
    final var expected = Pair.of(2, 4);
    assertEquals(expected, TwoSumProblem.twoSum(values, target).get());
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/backtracking/AllPathsFromSourceToTargetTest.java
Tests:
    "@Test
@Test
void testForFirstCase() {
    int vertices = 4;
    int[][] a = { { 0, 1 }, { 0, 2 }, { 0, 3 }, { 2, 0 }, { 2, 1 }, { 1, 3 } };
    int source = 2;
    int destination = 3;
    List<List<Integer>> list2 = List.of(List.of(2, 0, 1, 3), List.of(2, 0, 3), List.of(2, 1, 3));
    List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices, a, source, destination);
    list2 = list1;
    assertIterableEquals(list1, list2);
}
"
    "@Test
@Test
void testForSecondCase() {
    int vertices = 5;
    int[][] a = { { 0, 1 }, { 0, 2 }, { 0, 3 }, { 2, 0 }, { 2, 1 }, { 1, 3 }, { 1, 4 }, { 3, 4 }, { 2, 4 } };
    int source = 0;
    int destination = 4;
    List<List<Integer>> list2 = List.of(List.of(0, 1, 3, 4), List.of(0, 1, 4), List.of(0, 2, 1, 3, 4), List.of(0, 2, 1, 4), List.of(0, 2, 4), List.of(0, 3, 4));
    List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices, a, source, destination);
    list2 = list1;
    assertIterableEquals(list1, list2);
}
"
    "@Test
@Test
void testForThirdCase() {
    int vertices = 6;
    int[][] a = { { 1, 0 }, { 2, 3 }, { 0, 4 }, { 1, 5 }, { 4, 3 }, { 0, 2 }, { 0, 3 }, { 1, 2 }, { 0, 5 }, { 3, 4 }, { 2, 5 }, { 2, 4 } };
    int source = 1;
    int destination = 5;
    List<List<Integer>> list2 = List.of(List.of(1, 0, 2, 5), List.of(1, 0, 5), List.of(1, 5), List.of(1, 2, 5));
    List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices, a, source, destination);
    list2 = list1;
    assertIterableEquals(list1, list2);
}
"
    "@Test
@Test
void testForFourthcase() {
    int vertices = 3;
    int[][] a = { { 0, 1 }, { 0, 2 }, { 1, 2 } };
    int source = 0;
    int destination = 2;
    List<List<Integer>> list2 = List.of(List.of(0, 1, 2), List.of(0, 2));
    List<List<Integer>> list1 = AllPathsFromSourceToTarget.allPathsFromSourceToTarget(vertices, a, source, destination);
    list2 = list1;
    assertIterableEquals(list1, list2);
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/dynamicprogramming/LongestIncreasingSubsequenceTests.java
Tests:
    "@Test
private static Stream<Arguments> testCases() {
    final Object[][] testData = { { 0, new int[] {} }, { 1, new int[] { 1 } }, { 1, new int[] { 2, 2 } }, { 1, new int[] { 3, 3, 3 } }, { 1, new int[] { 4, 4, 4, 4 } }, { 1, new int[] { 5, 5, 5, 5, 5 } }, { 2, new int[] { 1, 2 } }, { 2, new int[] { 1, 2, 2, 2, 2 } }, { 2, new int[] { 1, 0, 2 } }, { 3, new int[] { 1, 10, 2, 30 } }, { 3, new int[] { 5, 8, 3, 7, 9, 1 } }, { 6, new int[] { 0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15 } }, { 4, new int[] { 10, 9, 2, 5, 3, 7, 101, 18 } }, { 4, new int[] { 10, 10, 9, 9, 2, 2, 5, 5, 3, 3, 7, 7, 101, 101, 18, 18 } }, { 4, new int[] { 0, 1, 0, 3, 2, 3 } }, { 2, new int[] { 1, 1, 2, 2, 2 } }, { 3, new int[] { 1, 1, 2, 2, 2, 3, 3, 3, 3 } } };
    final List<IntArrayToInt> methods = Arrays.asList(LongestIncreasingSubsequence::lis, LongestIncreasingSubsequence::findLISLen);
    return Stream.of(testData).flatMap(input -> methods.stream().map(method -> Arguments.of(input[0], input[1], method)));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/maths/FactorialRecursionTest.java
Tests:
    "@Test
private static Stream<Arguments> inputStream() {
    return Stream.of(Arguments.of(1, 0), Arguments.of(1, 1), Arguments.of(2, 2), Arguments.of(6, 3), Arguments.of(120, 5));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/maths/FindMinRecursionTest.java
Tests:
    "@Test
private static Stream<Arguments> inputStream() {
    return Stream.of(Arguments.of(5, new int[] { 5, 5, 5, 5, 5 }), Arguments.of(-1, new int[] { -1, 0 }), Arguments.of(-10, new int[] { -10, -9, -8, -7, -6, -5, -4, -3, -2, -1 }), Arguments.of(-4, new int[] { 3, -2, 3, 9, -4, -4, 8 }), Arguments.of(3, new int[] { 3 }));
}
"
File Path: /var/tmp/Roost/RoostGPT/java-customannotation-test/1724327801/source/Java/src/test/java/com/thealgorithms/sorts/SortUtilsTest.java
Tests:
    "@Test
@Test
void isSortedListTrue() {
    List<Integer> list = List.of(1, 1, 2, 3, 5, 8, 11);
    assertTrue(SortUtils.isSorted(list));
    List<Integer> identicalList = List.of(1, 1, 1, 1, 1);
    assertTrue(SortUtils.isSorted(identicalList));
    List<Double> doubles = List.of(-15.123, -15.111, 0.0, 0.12, 0.15);
    assertTrue(SortUtils.isSorted(doubles));
}
"
    "@Test
@Test
void isSortedListFalse() {
    List<Double> list = List.of(1.0, 3.0, -0.15);
    assertFalse(SortUtils.isSorted(list));
    List<Integer> array2 = List.of(14, 15, 16, 1);
    assertFalse(SortUtils.isSorted(array2));
    List<Integer> array3 = List.of(5, 4, 3, 2, 1);
    assertFalse(SortUtils.isSorted(array3));
}
"```markdown
Scenario 1: Valid Job Creation
Details:
  TestName: createValidJob
  Description: Validates if the method correctly creates a Job object with all parameters correctly passed.
Execution:
  Arrange: Prepare jobName, processingTime, and deadline parameters.
  Act: Call the method `of` with the prepared parameters.
  Assert: Verify that the returned Job object is not null and has the expected values for jobName, processingTime, and deadline.
Validation:
  Clarify that the assertion aims to verify the correct instantiation of a Job object with provided parameters. This test ensures that the method is capable of correctly handling valid inputs and creating an object that reflects these inputs.
Scenario 2: Job Creation with Empty Job Name
Details:
  TestName: createJobWithEmptyName
  Description: Tests the method's response to an empty string as the jobName.
Execution:
  Arrange: Use an empty string for jobName while providing valid integers for processingTime and deadline.
  Act: Call the `of` method with these parameters.
  Assert: Check if the returned Job object contains an empty jobName and the correct processingTime and deadline.
Validation:
  Validates that the method can handle and process an empty jobName without throwing errors, ensuring robustness in accepting varied string inputs.
Scenario 3: Job Creation with Negative Processing Time
Details:
  TestName: createJobWithNegativeProcessingTime
  Description: Tests how the method handles a negative processing time.
Execution:
  Arrange: Provide a valid jobName and deadline, but a negative integer for processingTime.
  Act: Call the `of` method with these parameters.
  Assert: Verify if the method handles the negative processing time appropriately, possibly by checking if an exception is thrown or if it defaults to a minimum value like 0.
Validation:
  This test checks the method's robustness in handling incorrect numerical inputs, ensuring that negative processing times are managed correctly to prevent logical errors in job processing.
Scenario 4: Job Creation with Negative Deadline
Details:
  TestName: createJobWithNegativeDeadline
  Description: Examines the method's behavior when provided with a negative deadline.
Execution:
  Arrange: Set a valid jobName and processingTime, but use a negative value for deadline.
  Act: Invoke the `of` method with these parameters.
  Assert: Check how the method responds to a negative deadline, such as throwing an exception or setting a default value.
Validation:
  Aims to verify the method's error handling capabilities with respect to time constraints, ensuring that job scheduling logic remains consistent and error-free even with potentially erroneous input.
Scenario 5: Job Creation with Null Job Name
Details:
  TestName: createJobWithNullName
  Description: Tests the behavior of the method when the jobName is null.
Execution:
  Arrange: Provide null for jobName and valid integers for processingTime and deadline.
  Act: Call the `of` method with these parameters.
  Assert: Determine if the method can gracefully handle a null jobName, possibly by checking for exceptions or null object creation.
Validation:
  This test confirms the method's robustness and error handling when faced with null inputs, ensuring that the application does not crash and provides meaningful feedback or handling.
```
These scenarios collectively ensure that the method `of` is thoroughly tested across a range of typical and edge case inputs, verifying both its functionality and resilience.
*/
// ********RoostGPT********
package com.thealgorithms.greedyalgorithms;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.Tag;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import org.junit.jupiter.api.*;
import java.util.Arrays;
import org.junit.jupiter.api.*;

@Tag("com.thealgorithms.greedyalgorithms")
@Tag("com.thealgorithms.greedyalgorithms.of")
public class MinimizingLatenessOfTest {
    @Test
    @Tag("valid")
    public void createValidJob() {
        // Arrange
        String jobName = "Job1";
        int processingTime = 5;
        int deadline = 10;
        // Act
        // Assuming Job is a class inside the same package and accessible from here
        Job result = new Job(jobName, processingTime, deadline);
        // Assert
        assertThat(result).isNotNull();
        assertThat(result.getJobName()).isEqualTo(jobName);
        assertThat(result.getProcessingTime()).isEqualTo(processingTime);
        assertThat(result.getDeadline()).isEqualTo(deadline);
    }
    @Test
    @Tag("invalid")
    public void createJobWithEmptyName() {
        // Arrange
        String jobName = "";
        int processingTime = 5;
        int deadline = 10;
        // Act
        Job result = new Job(jobName, processingTime, deadline);
        // Assert
        assertThat(result.getJobName()).isEmpty();
        assertThat(result.getProcessingTime()).isEqualTo(processingTime);
        assertThat(result.getDeadline()).isEqualTo(deadline);
    }
    @Test
    @Tag("boundary")
    public void createJobWithNegativeProcessingTime() {
        // Arrange
        String jobName = "Job2";
        int processingTime = -1;
        int deadline = 10;
        // Act & Assert
        assertThatThrownBy(() -> new Job(jobName, processingTime, deadline))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("Processing time cannot be negative");
    }
    @Test
    @Tag("boundary")
    public void createJobWithNegativeDeadline() {
        // Arrange
        String jobName = "Job3";
        int processingTime = 5;
        int deadline = -1;
        // Act & Assert
        assertThatThrownBy(() -> new Job(jobName, processingTime, deadline))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("Deadline cannot be negative");
    }
    @Test
    @Tag("invalid")
    public void createJobWithNullName() {
        // Arrange
        String jobName = null;
        int processingTime = 5;
        int deadline = 10;
        // Act & Assert
        assertThatThrownBy(() -> new Job(jobName, processingTime, deadline))
            .isInstanceOf(NullPointerException.class)
            .hasMessageContaining("Job name cannot be null");
    }
}